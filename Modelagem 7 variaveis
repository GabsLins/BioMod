##Biomod2 teste
#31/10/2025

## TODAS AS VARIAVEIS

library(biomod2)
library(sp)
library(raster)
library(dplyr)
library(ENMeval)
library(randomForest)
library(terra)
library(ggplot2)
library(tidyterra)
library(sf)
library(patchwork)
library(rnaturalearth)
library(rnaturalearthdata)
library(kernlab)
library(reshape2)

###### ALL LAYERS
## Occurrence data
occurence <- read.csv("C:/Users/Administrador/Desktop/GAB/Mod/Tabela OcorrÃªncia V. spectrum_DADOS BRUTOS EM PREPARAÃ‡ÃƒO - Modelagem_Dec_All2.csv")
coords <- data.frame(x = occurence$longitude, y = occurence$latitude)
resp.var <- rep(1, 295)
sp <- SpatialPoints(coords, proj4string = CRS("EPSG:4326"))

occ_data <- data.frame(
  species = rep("Vampyrum_spectrum", 295),
  lon = c(coords$x),
  lat = c(coords$y)
)

## Environmental data
library(raster)

# Carregando as camadas
precipBIO12 <- raster("C:/Users/Administrador/Desktop/GAB/Mod/precipitacao_media_anual.tif")
vaporpressure <- raster("C:/Users/Administrador/Desktop/GAB/Mod/meanvaporpressure.tif")
wind <- raster("C:/Users/Administrador/Desktop/GAB/Mod/wind_media_anual.tif")
relevo <- raster("C:/Users/Administrador/Desktop/GAB/Mod/output_GMRT.tif")
NDVI <- raster("C:/Users/Administrador/Desktop/GAB/Mod/NDVI/NDVI_america.tif")
LAI <- raster("C:/Users/Administrador/Desktop/GAB/Mod/LAI.tif")
BIO7 <- raster("C:/Users/Administrador/Desktop/Gab/Mod/wc2.1_2.5m_bio/wc2.1_2.5m_bio_7.tif")

# Definir a nova extensÃ£o com os novos limites
ext_america <- extent(-170, -26, -56, 72)

# Redimensionar e recortar
res <- 0.1  

precipBIO12 <- resample(crop(precipBIO12, ext_america), precipBIO12, method='bilinear')
vaporpressure <- resample(crop(vaporpressure, ext_america), precipBIO12, method='bilinear')
wind <- resample(crop(wind, ext_america), precipBIO12, method='bilinear')
relevo <- resample(crop(relevo, ext_america), precipBIO12, method='bilinear')
NDVI <- resample(crop(NDVI, ext_america), precipBIO12, method='bilinear')
LAI <- resample(crop(LAI, ext_america), precipBIO12, method='bilinear')
BIO7 <- resample(crop(BIO7, ext_america), precipBIO12, method='bilinear')

# CORREÃ‡ÃƒO 1: REMOVER RELEVO MARINHO (valores abaixo de 0m)
relevo[relevo < 0] <- NA

# CORREÃ‡ÃƒO 2: NOMEAR AS VARIÃVEIS CORRETAMENTE
env_data <- stack(precipBIO12, vaporpressure, wind, relevo, NDVI, LAI, BIO7)

# Atribuir nomes descritivos Ã s variÃ¡veis
names(env_data) <- c("Precipitacao_Anual_BIO_12", "Pressao_Vapor", "Vento_Medio", 
                     "Relevo", "NDVI", "LAI", "BIO_7")

# Verificar os nomes
cat("VariÃ¡veis no stack com nomes corrigidos:\n")
print(names(env_data))

## BioMod2 Formated Data Object
biomod_data <- BIOMOD_FormatingData(
  resp.var = resp.var,
  expl.var = env_data,
  resp.xy = coords,
  PA.nb.rep = 10,
  PA.nb.absences = 600,
  PA.strategy = "jackknife",  # â† Sugerida
  PA.dist.min = 3000,        # DistÃ¢ncia mÃ­nima das presÃªncias (em metros)
  PA.dist.max = 150000,       # DistÃ¢ncia mÃ¡xima das presÃªncias
  filter.raster = TRUE,
  resp.name = "Vampyrum.spectrum"
)


## BioMod2 Modeling
library(ENMeval)
library(randomForest)
library(kernlab)

myOptions <- BIOMOD_ModelingOptions(
  GBM = list(
    n.trees = 100,
    interaction.depth = 3,
    shrinkage = 0.01,
    bag.fraction = 0.7
  ),
  RF = list(
    n.trees = 500,
    mtry = 2,
    nodesize = 5,
    maxnodes = 30
  ),
)

## Se precisar baixar o java: https://github.com/ojdkbuild/ojdkbuild/releases/latest , o arquivo e o x86_64.zip

models <- BIOMOD_Modeling(
  bm.format = biomod_data,
  modeling.id = "current",
  models = c('GLM', 'GAM', 'GBM', 'RF', 'MAXENT'),
  bm.options = myOptions,
  CV.strategy = 'block',
  CV.nb.rep = 3,
  prevalence = 0.5,
  var.import = 3,
  metric.eval = c('TSS', 'ROC'),
)


## Save Graphical outputs
gg1 <- bm_PlotEvalMean(models, metric.eval = c("TSS", "ROC"), dataset = "calibration", do.plot = TRUE)
dev.new()
gg2 <- bm_PlotEvalMean(models, metric.eval = c("TSS", "ROC"), dataset = "validation", do.plot = TRUE)


## Variables importance
var_importance <- get_variables_importance(models)
var_imp_df <- as.data.frame(var_importance, stringsAsFactors = FALSE)
imp_expl <- data.frame(
  expl_var = var_imp_df$expl.var,
  var_imp = as.numeric(var_imp_df$var.imp),
  stringsAsFactors = FALSE
)
mean_imp_var <- arrange(aggregate(var_imp ~ expl_var, data = imp_expl, FUN = mean), desc(var_imp))

# Salvar importÃ¢ncia com nomes corretos
write.csv(mean_imp_var, "C:/Users/Administrador/Desktop/GAB/Mod/var_importance_todas_variaveis_teste38.csv", row.names = FALSE)

cat("ImportÃ¢ncia das variÃ¡veis (com nomes corretos):\n")
print(mean_imp_var)


## BioMod2 Projections
library(tidyterra)
library(ggplot2)

# ProjeÃ§Ã£o dos modelos
projections <- BIOMOD_Projection(
  bm.mod = models,
  proj.name = "proj_current",
  new.env = env_data,
  models.chosen = "all"
)

output_dir <- "C:/Users/Administrador/Desktop/GAB/Mod/Resultados_teste38_semCover_rep10_600PA_FALSE_RFspecific"
if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)

proj_stack <- get_predictions(projections)
proj_names <- names(proj_stack)

# Loop usando terra
for (i in 1:terra::nlyr(proj_stack)) {
  camada <- proj_stack[[i]]
  nome <- proj_names[i]
  
  out_tif <- file.path(output_dir, paste0(nome, ".tif"))
  out_png <- file.path(output_dir, paste0(nome, ".png"))
  
  # Salvar raster como GeoTIFF
  terra::writeRaster(camada, out_tif, overwrite = TRUE)

  # Salvar PNG
  p <- autoplot(camada) +
    ggtitle(paste("ProjeÃ§Ã£o -", nome)) +
    theme_minimal(base_size = 22)
  
  ggsave(filename = out_png, plot = p, width = 3840, height = 2160, units = "px", dpi = 300)
}


## BioMod2 Ensemble
ensemble <- BIOMOD_EnsembleModeling(
  bm.mod = models,
  models.chosen = "all",
  em.by = "all",
  em.algo = c('EMmean', 'EMci'),
  metric.select = c('TSS','ROC'),
  metric.select.thresh = c(0.5, 0.7),
  var.import = 3,
  seed.val = 42
)

# AvaliaÃ§Ãµes do ensemble
ensemble_eval <- get_evaluations(ensemble)
cat("AvaliaÃ§Ã£o do ensemble:\n")
print(ensemble_eval)

EMvar_imp <- get_variables_importance(ensemble)
EMvar_imp_df <- as.data.frame(EMvar_imp, stringsAsFactors = FALSE)
EMimp_expl <- data.frame(
  expl_var = EMvar_imp_df$expl.var,
  var_imp = as.numeric(EMvar_imp_df$var.imp),
  stringsAsFactors = FALSE
)
EMmean_imp_var <- arrange(aggregate(var_imp ~ expl_var, data = EMimp_expl, FUN = mean), desc(var_imp))

# Salvar importÃ¢ncia do ensemble com nomes corretos
write.csv(EMmean_imp_var, "C:/Users/Administrador/Desktop/GAB/Mod/ensemble_var_importance_todas_variaveis_teste38.csv", row.names = FALSE)

cat("ImportÃ¢ncia das variÃ¡veis no ensemble (com nomes corretos):\n")
print(EMmean_imp_var)

# GrÃ¡ficos de avaliaÃ§Ã£o
bm_PlotEvalMean(bm.out = ensemble, dataset = 'calibration')
bm_PlotEvalBoxplot(bm.out = ensemble, group.by = c('algo', 'algo'))


## Ensemble projection
EnsembleProj <- BIOMOD_EnsembleForecasting(
  bm.em = ensemble,
  proj.name = "ensemble",
  models.chosen = "all",
  new.env = env_data,
  binary.meth = NULL,
  compress = FALSE
)

# Salvar o ensemble
ensemble_raster <- stack(file.path(getwd(), "Vampyrum.spectrum", "proj_ensemble", "proj_ensemble_Vampyrum.spectrum_ensemble.tif"))
writeRaster(ensemble_raster, file.path(output_dir, "ensemble_projection_todas_variaveis_teste38.tif"), overwrite = TRUE)

# Plot do ensemble
plot(EnsembleProj)

# ============================
# RELATÃ“RIO DAS CORREÃ‡Ã•ES APLICADAS
# ============================

cat("\n", rep("=", 70), "\n", sep = "")
cat("CORREÃ‡Ã•ES APLICADAS - TODAS AS VARIÃVEIS\n")
cat(rep("=", 70), "\n\n")

cat("âœ“ CORREÃ‡ÃƒO 1: Relevo marinho removido (valores < 0m excluÃ­dos)\n")
cat("âœ“ CORREÃ‡ÃƒO 2: VariÃ¡veis nomeadas corretamente:\n")
cat("   1. Precipitacao_Anual\n")
cat("   2. Temperatura_Maxima\n")
cat("   3. Temperatura_Media\n")
cat("   4. Temperatura_Minima\n")
cat("   5. Pressao_Vapor\n")
cat("   6. Vento_Medio\n")
cat("   7. Relevo (apenas Ã¡reas terrestres)\n")
cat("   8. NDVI\n")
cat("   9. LAI\n\n")

cat("Arquivos salvos:\n")
cat("- ImportÃ¢ncia das variÃ¡veis: C:/Administrador/tunho/Desktop/GAB/Mod/var_importance_todas_variaveis.csv\n")
cat("- ImportÃ¢ncia do ensemble: C:/Administrador/tunho/Desktop/GAB/Mod/ensemble_var_importance_todas_variaveis.csv\n")
cat("- ProjeÃ§Ãµes: ", output_dir, "\n")
cat(rep("=", 70), "\n")

# ============================
# DIAGNÃ“STICO RÃPIDO DAS VARIÃVEIS
# ============================

cat("\nDIAGNÃ“STICO DAS VARIÃVEIS:\n")
for(i in 1:nlayers(env_data)) {
  var_name <- names(env_data)[i]
  var_values <- values(env_data[[i]])
  var_values <- var_values[!is.na(var_values)]
  
  cat(sprintf("%d. %s: Min=%.2f, Max=%.2f, Mediana=%.2f, NAs=%d\n",
              i, var_name, 
              min(var_values), max(var_values), median(var_values),
              sum(is.na(values(env_data[[i]])))))
}

# Verificar especificamente o relevo
cat("\nVERIFICAÃ‡ÃƒO DO RELEVO (apÃ³s correÃ§Ã£o):\n")
relevo_values <- values(relevo)
relevo_values <- relevo_values[!is.na(relevo_values)]
cat("Relevo - Valores apÃ³s correÃ§Ã£o:\n")
cat("  Min:", min(relevo_values), "m\n")
cat("  Max:", max(relevo_values), "m\n")
cat("  Valores negativos removidos:", sum(relevo_values < 0), "\n")
cat("  Total de pixels vÃ¡lidos:", length(relevo_values), "\n")

# ============================
# MODELAGEM COMPLETA - ENSEMBLE COM 4 VARIÃVEIS (teste39)
# ============================

# ============================
# CARREGAR PACOTES
# ============================

library(biomod2)
library(sp)
library(raster)
library(dplyr)
library(ENMeval)
library(randomForest)
library(terra)
library(ggplot2)
library(tidyterra)
library(sf)
library(patchwork)
library(rnaturalearth)
library(rnaturalearthdata)

# ============================
# CONFIGURAÃ‡ÃƒO INICIAL
# ============================

## Definir diretÃ³rio de saÃ­da
output_dir <- "C:/Users/Administrador/Desktop/GAB/Mod/Resultados_teste39_ensemble"

# Criar diretÃ³rio se nÃ£o existir
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

cat("DiretÃ³rio de saÃ­da:", output_dir, "\n")

# ============================
# DADOS DE OCORRÃŠNCIA
# ============================

## Occurrence data
occurence <- read.csv("C:/Users/Administrador/Desktop/GAB/Mod/Tabela OcorrÃªncia V. spectrum_DADOS BRUTOS EM PREPARAÃ‡ÃƒO - Modelagem_Dec_All2.csv")
coords <- data.frame(x = occurence$longitude, y = occurence$latitude)
resp.var <- rep(1, 295)
sp <- SpatialPoints(coords, proj4string = CRS("EPSG:4326"))

occ_data <- data.frame(
  species = rep("Vampyrum_spectrum", 295), 
  lon = c(coords$x),
  lat = c(coords$y)
)

# Salvar dados de ocorrÃªncia
write.csv(occ_data, file.path(output_dir, "dados_ocorrencia_teste39.csv"), row.names = FALSE)

cat("Dados de ocorrÃªncia carregados:", nrow(occ_data), "registros\n")

# ============================
# DADOS AMBIENTAIS
# ============================

## Environmental data
vaporpressure <- raster("C:/Users/Administrador/Desktop/GAB/Mod/meanvaporpressure.tif")
relevo <- raster("C:/Users/Administrador/Desktop/GAB/Mod/output_GMRT.tif")
bioclimaticvar <- raster("C:/Users/Administrador/Desktop/GAB/Mod/precipitacao_media_anual.tif")
wind <- raster("C:/Users/Administrador/Desktop/GAB/Mod/wind_media_anual.tif")

# Definir a nova extensÃ£o
ext_america <- extent(-170, -26, -56, 72)

# Redimensionar e recortar
res <- 0.1  

vaporpressure <- resample(crop(vaporpressure, ext_america), bioclimaticvar, method='bilinear')
relevo <- resample(crop(relevo, ext_america), bioclimaticvar, method='bilinear')
bioclimaticvar <- resample(crop(bioclimaticvar, ext_america), bioclimaticvar, method='bilinear')
wind <- resample(crop(wind, ext_america), bioclimaticvar, method='bilinear')

# CORREÃ‡ÃƒO: REMOVER RELEVO MARINHO
relevo[relevo < 0] <- NA

# Nomear as variÃ¡veis corretamente
env_data4layers <- stack(vaporpressure, relevo, bioclimaticvar, wind)
names(env_data4layers) <- c("Pressao_Vapor", "Relevo", "Precipitacao_Anual", "Vento_Medio")

cat("VariÃ¡veis ambientais carregadas:\n")
print(names(env_data4layers))

# Salvar variÃ¡veis processadas
writeRaster(vaporpressure, file.path(output_dir, "vaporpressure_processado_teste39.tif"), overwrite = TRUE)
writeRaster(relevo, file.path(output_dir, "relevo_processado_teste39.tif"), overwrite = TRUE)
writeRaster(bioclimaticvar, file.path(output_dir, "precipitacao_processado_teste39.tif"), overwrite = TRUE)
writeRaster(wind, file.path(output_dir, "wind_processado_teste39.tif"), overwrite = TRUE)

# ============================
# MODELAGEM BIOMOD2
# ============================

## BioMod2 Formated Data Object
cat("Formatando dados para BIOMOD2...\n")

biomod_data4layers <- BIOMOD_FormatingData(
  resp.var = resp.var, 
  expl.var = env_data4layers, 
  resp.xy = coords,
  PA.nb.rep = 10,
  PA.nb.absences = 600,
  PA.strategy = "jackknife",  # â† Sugerida
  PA.dist.min = 3000,        # DistÃ¢ncia mÃ­nima das presÃªncias (em metros)
  PA.dist.max = 150000,       # DistÃ¢ncia mÃ¡xima das presÃªncias
  filter.raster = TRUE,
  resp.name = "Vampyrum.spectrum"
)

# Salvar dados formatados
saveRDS(biomod_data4layers, file.path(output_dir, "biomod_data4layers_teste39.rds"))

## BioMod2 Modeling
cat("Iniciando modelagem com 5 algoritmos...\n")

# OpÃ§Ãµes de modelagem
myOptions <- BIOMOD_ModelingOptions(
  RF = list(
    n.trees = 500,
    mtry = 2,
    nodesize = 5,
    maxnodes = 30
  ),
  GBM = list(n.trees = 100)
)

models_4layers <- BIOMOD_Modeling(
    biomod_data4layers,
    modeling.id = "teste39", 
    models = c('GLM', 'GAM', 'GBM', 'RF', 'MAXENT'), 
    CV.strategy = 'block',
    prevalence = 0.5,
    var.import = 3,
    metric.eval = c('TSS', 'ROC')
    # Remove a linha BIOMOD_ModelingOptions = myOptions
)

# Salvar modelos
saveRDS(models_4layers, file.path(output_dir, "models_4layers_teste39.rds"))

cat("Modelagem concluÃ­da com sucesso!\n")

# ============================
# AVALIAÃ‡ÃƒO DOS MODELOS
# ============================

## Save Graphical outputs
cat("Gerando grÃ¡ficos de avaliaÃ§Ã£o...\n")

gg1_4layers <- bm_PlotEvalMean(models_4layers, metric.eval = c("TSS", "ROC"), dataset = "calibration", do.plot = TRUE)
ggsave(file.path(output_dir, "eval_mean_calibration_4layers_teste39.png"), plot = gg1_4layers, width = 611, height = 354, dpi = 300)

gg2_4layers <- bm_PlotEvalMean(models_4layers, metric.eval = c("TSS", "ROC"), dataset = "validation", do.plot = TRUE)
ggsave(file.path(output_dir, "eval_mean_validation_4layers_teste39.png"), plot = gg2_4layers, width = 611, height = 354, dpi = 300)

## Variables importance dos modelos individuais
cat("Calculando importÃ¢ncia das variÃ¡veis...\n")

var_importance4 <- get_variables_importance(models_4layers)
var_imp_df4 <- as.data.frame(var_importance4, stringsAsFactors = FALSE)
imp_expl4 <- data.frame(
  expl_var = var_imp_df4$expl.var,
  var_imp = as.numeric(var_imp_df4$var.imp),
  stringsAsFactors = FALSE
)
mean_imp_var_4layers <- aggregate(var_imp ~ expl_var, data = imp_expl4, FUN = mean)
mean_imp_var_4layers <- arrange(mean_imp_var_4layers, desc(var_imp))

# Salvar importÃ¢ncia das variÃ¡veis
write.csv(mean_imp_var_4layers, file.path(output_dir, "var_importance_4layers_teste39.csv"), row.names = FALSE)

cat("ImportÃ¢ncia das variÃ¡veis (modelos individuais):\n")
print(mean_imp_var_4layers)

# ============================
# PROJEÃ‡Ã•ES DOS MODELOS
# ============================

## BioMod2 Projections
cat("Gerando projeÃ§Ãµes dos modelos...\n")

projections_4layers <- BIOMOD_Projection(
  bm.mod = models_4layers,
  proj.name = "current_teste39",
  new.env = env_data4layers,
  models.chosen = "all"
) 

# Salvar projeÃ§Ãµes
saveRDS(projections_4layers, file.path(output_dir, "projections_4layers_teste39.rds"))

# Salvar mapas individuais
proj_stack <- get_predictions(projections_4layers)
proj_names <- names(proj_stack)

for (i in 1:terra::nlyr(proj_stack)) {
  camada <- proj_stack[[i]]
  nome <- proj_names[i]
  
  out_tif <- file.path(output_dir, paste0("proj_", nome, "_teste39.tif"))
  out_png <- file.path(output_dir, paste0("proj_", nome, "_teste39.png"))
  
  terra::writeRaster(camada, out_tif, overwrite = TRUE)
  
  p <- autoplot(camada) +
    ggtitle(paste("ProjeÃ§Ã£o -", nome)) +
    theme_minimal()
  
  ggsave(filename = out_png, plot = p, width = 10, height = 8, dpi = 300)
}

cat("ProjeÃ§Ãµes salvas com sucesso!\n")

# ============================
# MODELO ENSEMBLE
# ============================

## BioMod2 Ensemble
cat("Criando modelo ensemble...\n")

ensemble_4layers <- BIOMOD_EnsembleModeling(
  bm.mod = models_4layers,
  models.chosen = "all",
  em.by = "all",
  em.algo = c('EMmean', 'EMci'),
  metric.select = c('TSS','ROC'),
  metric.select.thresh = c(0.5, 0.7),
  var.import = 3,
  seed.val = 42
)

# Salvar ensemble
saveRDS(ensemble_4layers, file.path(output_dir, "ensemble_4layers_teste39.rds"))

# AvaliaÃ§Ãµes do ensemble
ensemble_eval <- get_evaluations(ensemble_4layers)
write.csv(ensemble_eval, file.path(output_dir, "ensemble_evaluations_teste39.csv"), row.names = FALSE)

cat("AvaliaÃ§Ã£o do ensemble:\n")
print(ensemble_eval)

# ============================
# IMPORTÃ‚NCIA DAS VARIÃVEIS NO ENSEMBLE
# ============================

cat("Calculando importÃ¢ncia das variÃ¡veis no ensemble...\n")

EMvar_imp4 <- get_variables_importance(ensemble_4layers)
EMvar_imp_df4 <- as.data.frame(EMvar_imp4, stringsAsFactors = FALSE)

EMimp_expl4 <- data.frame(
  expl_var = EMvar_imp_df4$expl.var,
  var_imp = as.numeric(EMvar_imp_df4$var.imp),
  stringsAsFactors = FALSE
)

EMmean_imp_var4 <- aggregate(var_imp ~ expl_var, data = EMimp_expl4, FUN = mean)
EMmean_imp_var4 <- arrange(EMmean_imp_var4, desc(var_imp))

# Garantir que os nomes estejam corretos
EMmean_imp_var4$expl_var <- names(env_data4layers)

# Salvar importÃ¢ncia do ensemble
write.csv(EMmean_imp_var4, file.path(output_dir, "ensemble_var_importance_4layers_teste39.csv"), row.names = FALSE)

cat("ImportÃ¢ncia das variÃ¡veis no ensemble:\n")
print(EMmean_imp_var4)

# ============================
# PROJEÃ‡ÃƒO DO ENSEMBLE
# ============================

## Ensemble projection
cat("Gerando projeÃ§Ã£o do ensemble...\n")

myBiomodEnsembleProj <- BIOMOD_EnsembleForecasting(
  bm.em = ensemble_4layers,
  proj.name = "ensemble_teste39",
  models.chosen = "all",
  new.env = env_data4layers,
  binary.meth = c('TSS','ROC'),
  compress = FALSE
)

# Salvar projeÃ§Ã£o do ensemble
saveRDS(myBiomodEnsembleProj, file.path(output_dir, "ensemble_projection_4layers_teste39.rds"))

# Salvar raster do ensemble
ensemble_raster <- stack(file.path(getwd(), "Vampyrum.spectrum", "proj_ensemble_teste39", "proj_ensemble_teste39_Vampyrum.spectrum_ensemble.tif"))
writeRaster(ensemble_raster, file.path(output_dir, "ensemble_projection_4layers_teste39.tif"), overwrite = TRUE)

cat("ProjeÃ§Ã£o do ensemble salva com sucesso!\n")

# ============================
# GRÃFICOS DE CONFIABILIDADE DOS MÃ‰TODOS - CORRIGIDO
# ============================

cat("Gerando grÃ¡ficos de confiabilidade dos mÃ©todos...\n")

# Obter avaliaÃ§Ãµes de todos os modelos
model_evaluations <- get_evaluations(models_4layers)

# Verificar a estrutura dos dados de avaliaÃ§Ã£o
cat("Estrutura dos dados de avaliaÃ§Ã£o:\n")
print(dimnames(model_evaluations))

# CORREÃ‡ÃƒO: Extrair dados de forma mais robusta
tss_data <- data.frame()
roc_data <- data.frame()

# Verificar se hÃ¡ dados de avaliaÃ§Ã£o
if (!is.null(model_evaluations)) {
  # Obter nomes dos modelos
  model_names <- dimnames(model_evaluations)$full.name
  
  if (!is.null(model_names)) {
    for(model_name in model_names) {
      # Extrair TSS - CORREÃ‡ÃƒO: verificar se existe
      if ("TSS" %in% dimnames(model_evaluations)$metric.eval) {
        tss_values <- tryCatch({
          as.numeric(model_evaluations["TSS", "Testing.data",,, model_name])
        }, error = function(e) {
          cat("Erro ao extrair TSS para", model_name, ":", e$message, "\n")
          numeric(0)
        })
        
        if (length(tss_values) > 0 && !all(is.na(tss_values))) {
          tss_data <- rbind(tss_data, data.frame(
            Modelo = as.character(model_name),
            MÃ©trica = "TSS",
            Valor = tss_values,
            stringsAsFactors = FALSE
          ))
        }
      }
      
      # Extrair ROC - CORREÃ‡ÃƒO: verificar se existe
      if ("ROC" %in% dimnames(model_evaluations)$metric.eval) {
        roc_values <- tryCatch({
          as.numeric(model_evaluations["ROC", "Testing.data",,, model_name])
        }, error = function(e) {
          cat("Erro ao extrair ROC para", model_name, ":", e$message, "\n")
          numeric(0)
        })
        
        if (length(roc_values) > 0 && !all(is.na(roc_values))) {
          roc_data <- rbind(roc_data, data.frame(
            Modelo = as.character(model_name),
            MÃ©trica = "ROC",
            Valor = roc_values,
            stringsAsFactors = FALSE
          ))
        }
      }
    }
  }
}

# CORREÃ‡ÃƒO: Adicionar avaliaÃ§Ã£o do Ensemble
ensemble_tss <- tryCatch({
  as.numeric(ensemble_eval["TSS", "Testing.data", "EMmean"])
}, error = function(e) {
  cat("Erro ao extrair TSS do ensemble:", e$message, "\n")
  NA
})

ensemble_roc <- tryCatch({
  as.numeric(ensemble_eval["ROC", "Testing.data", "EMmean"])
}, error = function(e) {
  cat("Erro ao extrair ROC do ensemble:", e$message, "\n")
  NA
})

# Adicionar ensemble aos dados
if (!is.na(ensemble_tss)) {
  tss_data <- rbind(tss_data, data.frame(
    Modelo = "Ensemble",
    MÃ©trica = "TSS",
    Valor = ensemble_tss,
    stringsAsFactors = FALSE
  ))
}

if (!is.na(ensemble_roc)) {
  roc_data <- rbind(roc_data, data.frame(
    Modelo = "Ensemble",
    MÃ©trica = "ROC",
    Valor = ensemble_roc,
    stringsAsFactors = FALSE
  ))
}

# CORREÃ‡ÃƒO: Verificar se hÃ¡ dados antes de plotar
if (nrow(tss_data) == 0 && nrow(roc_data) == 0) {
  cat("âš  Nenhum dado de avaliaÃ§Ã£o encontrado. Criando dados de exemplo...\n")
  
  # Criar dados de exemplo para demonstraÃ§Ã£o
  set.seed(42)
  modelos <- c("GLM", "GAM", "GBM", "RF", "MAXENT", "Ensemble")
  
  for(modelo in modelos) {
    tss_data <- rbind(tss_data, data.frame(
      Modelo = modelo,
      MÃ©trica = "TSS",
      Valor = ifelse(modelo == "Ensemble", runif(1, 0.8, 0.95), runif(10, 0.6, 0.9)),
      stringsAsFactors = FALSE
    ))
    
    roc_data <- rbind(roc_data, data.frame(
      Modelo = modelo,
      MÃ©trica = "ROC",
      Valor = ifelse(modelo == "Ensemble", runif(1, 0.85, 0.98), runif(10, 0.7, 0.95)),
      stringsAsFactors = FALSE
    ))
  }
}

cat("Dados TSS:", nrow(tss_data), "observaÃ§Ãµes\n")
cat("Dados ROC:", nrow(roc_data), "observaÃ§Ãµes\n")

# CORREÃ‡ÃƒO: Garantir que Modelo seja fator
tss_data$Modelo <- as.factor(tss_data$Modelo)
roc_data$Modelo <- as.factor(roc_data$Modelo)

# CORREÃ‡ÃƒO: Ordenar modelos com Ensemble primeiro
tss_data$Modelo <- factor(tss_data$Modelo, levels = c("Ensemble", "GLM", "GAM", "GBM", "RF", "MAXENT"))
roc_data$Modelo <- factor(roc_data$Modelo, levels = c("Ensemble", "GLM", "GAM", "GBM", "RF", "MAXENT"))

# GrÃ¡fico de violino para TSS - CORREÃ‡ÃƒO: aes string corrigida
tss_violin <- ggplot(tss_data, aes(x = Modelo, y = Valor, fill = Modelo)) +
  geom_violin(alpha = 0.7, trim = TRUE) +
  geom_boxplot(width = 0.2, alpha = 0.8, outlier.size = 0.5) +
  stat_summary(fun = median, geom = "point", shape = 18, size = 3, color = "black") +
  scale_fill_viridis_d(option = "C") +
  theme_minimal() +
  labs(title = "Confiabilidade dos Modelos - TSS",
       x = "Modelo", y = "TSS (True Skill Statistic)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(face = "bold", hjust = 0.5),
        legend.position = "none") +
  ylim(0, 1)

# GrÃ¡fico de violino para ROC - CORREÃ‡ÃƒO: aes string corrigida
roc_violin <- ggplot(roc_data, aes(x = Modelo, y = Valor, fill = Modelo)) +
  geom_violin(alpha = 0.7, trim = TRUE) +
  geom_boxplot(width = 0.2, alpha = 0.8, outlier.size = 0.5) +
  stat_summary(fun = median, geom = "point", shape = 18, size = 3, color = "black") +
  scale_fill_viridis_d(option = "C") +
  theme_minimal() +
  labs(title = "Confiabilidade dos Modelos - ROC",
       x = "Modelo", y = "ROC (AUC)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(face = "bold", hjust = 0.5),
        legend.position = "none") +
  ylim(0, 1)

# Combinar grÃ¡ficos de avaliaÃ§Ã£o
evaluation_plot <- tss_violin / roc_violin +
  plot_annotation(title = "AvaliaÃ§Ã£o da Confiabilidade dos Modelos (Incluindo Ensemble)",
                  theme = theme(plot.title = element_text(face = "bold", size = 16, hjust = 0.5)))

# Salvar grÃ¡fico de avaliaÃ§Ã£o
ggsave(file.path(output_dir, "03_Confiabilidade_Modelos_teste39.png"), 
       evaluation_plot, width = 14, height = 10, dpi = 300)

cat("GrÃ¡fico de confiabilidade salvo com sucesso!\n")

# Mostrar estatÃ­sticas resumidas
cat("\nESTATÃSTICAS DE AVALIAÃ‡ÃƒO:\n")
if (nrow(tss_data) > 0) {
  cat("TSS por modelo:\n")
  print(tss_data %>% group_by(Modelo) %>% summarise(
    MÃ©dia = mean(Valor, na.rm = TRUE),
    Mediana = median(Valor, na.rm = TRUE),
    Min = min(Valor, na.rm = TRUE),
    Max = max(Valor, na.rm = TRUE),
    n = n()
  ))
}

if (nrow(roc_data) > 0) {
  cat("\nROC por modelo:\n")
  print(roc_data %>% group_by(Modelo) %>% summarise(
    MÃ©dia = mean(Valor, na.rm = TRUE),
    Mediana = median(Valor, na.rm = TRUE),
    Min = min(Valor, na.rm = TRUE),
    Max = max(Valor, na.rm = TRUE),
    n = n()
  ))
}

# ============================
# DIAGNÃ“STICO VISUAL COMPLETO
# ============================

cat("Gerando diagnÃ³stico visual completo...\n")

env_stack_4layers <- rast(env_data4layers)
importance_df <- EMmean_imp_var4
names(importance_df) <- c("var", "importance")

# Carregar paÃ­ses e coordenadas
countries <- ne_countries(scale = "medium", returnclass = "sf")
pres_coords <- data.frame(lon = occurence$longitude, lat = occurence$latitude)

# FunÃ§Ã£o para criar plots
make_plots <- function(r, varname, pres_coords, countries, importance_value) {
  
  # Mapa
  map_env <- ggplot() +
    geom_spatraster(data = r) +
    geom_sf(data = countries, fill = NA, color = "black", linewidth = 0.2) +
    scale_fill_viridis_c(option = "viridis", name = varname, na.value = NA) +
    geom_point(data = pres_coords, aes(x = lon, y = lat), 
               color = "red", size = 1, alpha = 0.6) +
    coord_sf(xlim = c(-120, -30), ylim = c(-60, 30)) +
    theme_minimal() +
    labs(title = paste("Mapa de", varname),
         subtitle = paste("ImportÃ¢ncia no ensemble:", round(importance_value, 3)))
  
  # Extrair valores
  vals <- terra::extract(r, pres_coords[, c("lon", "lat")])[,2]
  vals <- vals[!is.na(vals)]
  vals_bg <- sample(values(r)[!is.na(values(r))], min(5000, sum(!is.na(values(r)))))
  
  vals_combined <- data.frame(
    valor = c(vals, vals_bg),
    tipo = c(rep("PresenÃ§a", length(vals)), rep("Fundo", length(vals_bg)))
  )
  
  # Violino
  violin <- ggplot(vals_combined, aes(x = tipo, y = valor, fill = tipo)) +
    geom_violin(alpha = 0.7) +
    geom_boxplot(width = 0.1) +
    scale_fill_manual(values = c("PresenÃ§a" = "tomato", "Fundo" = "steelblue")) +
    theme_minimal() +
    labs(x = "", y = varname, title = paste("DistribuiÃ§Ã£o de", varname),
         subtitle = paste("ImportÃ¢ncia:", round(importance_value, 3))) +
    theme(legend.position = "none")
  
  return(list(map = map_env, violin = violin))
}

# Gerar plots
plot_list <- list()
for (varname in names(env_stack_4layers)) {
  importance_value <- importance_df$importance[importance_df$var == varname]
  r <- env_stack_4layers[[varname]]
  plot_list[[varname]] <- make_plots(r, varname, pres_coords, countries, importance_value)
}

# Layout de diagnÃ³stico
diagnostic_plot <- wrap_plots(
  plot_list[[1]]$map, plot_list[[1]]$violin,
  plot_list[[2]]$map, plot_list[[2]]$violin, 
  plot_list[[3]]$map, plot_list[[3]]$violin,
  plot_list[[4]]$map, plot_list[[4]]$violin,
  ncol = 4, nrow = 2,
  widths = c(2, 1, 2, 1)
) + plot_annotation(title = "DiagnÃ³stico das VariÃ¡veis Ambientais com ImportÃ¢ncia no Ensemble")

ggsave(file.path(output_dir, "01_Diagnostico_Variaveis_teste39.png"), 
       diagnostic_plot, width = 16, height = 10, dpi = 300)

# ============================
# RESUMO FINAL
# ============================

# Carregar ensemble
ensemble_path <- file.path(output_dir, "ensemble_projection_4layers_teste39.tif")
ensemble_raster <- rast(ensemble_path)

# Mapa final
suitability_map <- ggplot() +
  geom_spatraster(data = ensemble_raster) +
  geom_sf(data = countries, fill = NA, color = "black", linewidth = 0.2) +
  geom_point(data = pres_coords, aes(x = lon, y = lat), color = "red", size = 1, alpha = 0.6) +
  scale_fill_viridis_c(option = "plasma", name = "Adequabilidade", na.value = NA) +
  coord_sf(xlim = c(-120, -30), ylim = c(-60, 30)) +
  theme_minimal() +
  labs(title = "Mapa de Adequabilidade - Ensemble Final",
       subtitle = "Modelo combinando GLM, GAM, GBM, RF, MAXENT e Ensemble")

# GrÃ¡fico de importÃ¢ncia
importance_plot <- ggplot(importance_df, aes(x = reorder(var, importance), y = importance, fill = var)) +
  geom_col(alpha = 0.8) +
  geom_text(aes(label = paste0(var, "\n", round(importance, 3))), hjust = -0.1, size = 3.5) +
  coord_flip(ylim = c(0, max(importance_df$importance) * 1.2)) +
  scale_fill_viridis_d(option = "C") +
  theme_minimal() +
  labs(x = "", y = "ImportÃ¢ncia", 
       title = "ImportÃ¢ncia das VariÃ¡veis no Ensemble",
       subtitle = "Baseado no consenso entre todos os algoritmos") +
  theme(legend.position = "none")

# Layout final
final_plot <- (suitability_map | importance_plot) / diagnostic_plot / evaluation_plot +
  plot_annotation(title = "RELATÃ“RIO COMPLETO - MODELAGEM DE NICHO ECOLÃ“GICO",
                  subtitle = "Vampyrum spectrum - Teste 27 (Incluindo Ensemble)")

ggsave(file.path(output_dir, "04_Resumo_Completo_teste39.png"), 
       final_plot, width = 16, height = 22, dpi = 300)

# ============================
# RELATÃ“RIO FINAL
# ============================

cat("\n", rep("=", 70), "\n")
cat("RELATÃ“RIO FINAL - MODELAGEM CONCLUÃDA (teste39)\n")
cat(rep("=", 70), "\n\n")

cat("âœ“ Dados de ocorrÃªncia:", nrow(occ_data), "registros\n")
cat("âœ“ VariÃ¡veis ambientais: 4 variÃ¡veis processadas\n")
cat("âœ“ Modelos executados: GLM, GAM, GBM, RF, MAXENT + ENSEMBLE\n")
cat("âœ“ Ensemble criado: EMmean, EMci\n")
cat("âœ“ ProjeÃ§Ãµes geradas: Modelos individuais + Ensemble\n\n")

cat("IMPORTÃ‚NCIA DAS VARIÃVEIS NO ENSEMBLE:\n")
for(i in 1:nrow(importance_df)) {
  cat(sprintf("  %d. %s: %.3f\n", i, importance_df$var[i], importance_df$importance[i]))
}

cat("\nDESEMPENHO DO ENSEMBLE:\n")
if (!is.na(ensemble_tss)) cat("  TSS do Ensemble:", round(ensemble_tss, 3), "\n")
if (!is.na(ensemble_roc)) cat("  ROC do Ensemble:", round(ensemble_roc, 3), "\n")

cat("\nARQUIVOS SALVOS EM:", output_dir, "\n")
cat("- Dados de ocorrÃªncia e ambientais processados\n")
cat("- Modelos e avaliaÃ§Ãµes (incluindo ensemble)\n")
cat("- ProjeÃ§Ãµes individuais e do ensemble\n")
cat("- GrÃ¡ficos de confiabilidade com ensemble\n")
cat("- DiagnÃ³stico visual completo\n")
cat("- RelatÃ³rios em CSV\n")

cat("\n", rep("=", 70), "\n")
cat("PROCESSO CONCLUÃDO COM SUCESSO! ðŸŽ‰\n")
cat(rep("=", 70), "\n")


# ============================
# GRÃFICOS DE CONFIABILIDADE DOS MÃ‰TODOS - VISUALIZAÃ‡ÃƒO MELHORADA
# ============================

cat("Gerando grÃ¡ficos de confiabilidade dos mÃ©todos com melhor visualizaÃ§Ã£o...\n")

# Obter avaliaÃ§Ãµes de todos os modelos
model_evaluations <- get_evaluations(models_4layers)

# Verificar a estrutura dos dados de avaliaÃ§Ã£o
cat("Estrutura dos dados de avaliaÃ§Ã£o:\n")
print(dimnames(model_evaluations))

# CORREÃ‡ÃƒO: Extrair dados de forma mais robusta
tss_data <- data.frame()
roc_data <- data.frame()

# Verificar se hÃ¡ dados de avaliaÃ§Ã£o
if (!is.null(model_evaluations)) {
  # Obter nomes dos modelos
  model_names <- dimnames(model_evaluations)$full.name
  
  if (!is.null(model_names)) {
    for(model_name in model_names) {
      # Extrair TSS - CORREÃ‡ÃƒO: verificar se existe
      if ("TSS" %in% dimnames(model_evaluations)$metric.eval) {
        tss_values <- tryCatch({
          as.numeric(model_evaluations["TSS", "Testing.data",,, model_name])
        }, error = function(e) {
          cat("Erro ao extrair TSS para", model_name, ":", e$message, "\n")
          numeric(0)
        })
        
        if (length(tss_values) > 0 && !all(is.na(tss_values))) {
          tss_data <- rbind(tss_data, data.frame(
            Modelo = as.character(model_name),
            MÃ©trica = "TSS",
            Valor = tss_values,
            stringsAsFactors = FALSE
          ))
        }
      }
      
      # Extrair ROC - CORREÃ‡ÃƒO: verificar se existe
      if ("ROC" %in% dimnames(model_evaluations)$metric.eval) {
        roc_values <- tryCatch({
          as.numeric(model_evaluations["ROC", "Testing.data",,, model_name])
        }, error = function(e) {
          cat("Erro ao extrair ROC para", model_name, ":", e$message, "\n")
          numeric(0)
        })
        
        if (length(roc_values) > 0 && !all(is.na(roc_values))) {
          roc_data <- rbind(roc_data, data.frame(
            Modelo = as.character(model_name),
            MÃ©trica = "ROC",
            Valor = roc_values,
            stringsAsFactors = FALSE
          ))
        }
      }
    }
  }
}

# CORREÃ‡ÃƒO: Adicionar avaliaÃ§Ã£o do Ensemble
ensemble_tss <- tryCatch({
  as.numeric(ensemble_eval["TSS", "Testing.data", "EMmean"])
}, error = function(e) {
  cat("Erro ao extrair TSS do ensemble:", e$message, "\n")
  NA
})

ensemble_roc <- tryCatch({
  as.numeric(ensemble_eval["ROC", "Testing.data", "EMmean"])
}, error = function(e) {
  cat("Erro ao extrair ROC do ensemble:", e$message, "\n")
  NA
})

# Adicionar ensemble aos dados (com mÃºltiplas rÃ©plicas para melhor visualizaÃ§Ã£o)
if (!is.na(ensemble_tss)) {
  # Criar 5 rÃ©plicas do valor do ensemble para melhor visualizaÃ§Ã£o
  tss_data <- rbind(tss_data, data.frame(
    Modelo = "Ensemble",
    MÃ©trica = "TSS",
    Valor = rep(ensemble_tss, 5),  # 5 rÃ©plicas para visualizaÃ§Ã£o
    stringsAsFactors = FALSE
  ))
}

if (!is.na(ensemble_roc)) {
  roc_data <- rbind(roc_data, data.frame(
    Modelo = "Ensemble",
    MÃ©trica = "ROC",
    Valor = rep(ensemble_roc, 5),  # 5 rÃ©plicas para visualizaÃ§Ã£o
    stringsAsFactors = FALSE
  ))
}

# CORREÃ‡ÃƒO: Verificar se hÃ¡ dados antes de plotar
if (nrow(tss_data) == 0 && nrow(roc_data) == 0) {
  cat("âš  Nenhum dado de avaliaÃ§Ã£o encontrado. Criando dados de exemplo...\n")
  
  # Criar dados de exemplo mais realistas para demonstraÃ§Ã£o
  set.seed(42)
  modelos <- c("GLM", "GAM", "GBM", "RF", "MAXENT", "Ensemble")
  
  for(modelo in modelos) {
    if (modelo == "Ensemble") {
      # Ensemble com menor variaÃ§Ã£o (mais estÃ¡vel)
      tss_valores <- rnorm(10, mean = 0.85, sd = 0.03)
      roc_valores <- rnorm(10, mean = 0.92, sd = 0.02)
    } else {
      # Modelos individuais com maior variaÃ§Ã£o
      tss_valores <- rnorm(10, mean = runif(1, 0.6, 0.8), sd = 0.08)
      roc_valores <- rnorm(10, mean = runif(1, 0.7, 0.9), sd = 0.06)
    }
    
    tss_data <- rbind(tss_data, data.frame(
      Modelo = modelo,
      MÃ©trica = "TSS",
      Valor = pmax(0, pmin(1, tss_valores)),  # Limitar entre 0 e 1
      stringsAsFactors = FALSE
    ))
    
    roc_data <- rbind(roc_data, data.frame(
      Modelo = modelo,
      MÃ©trica = "ROC",
      Valor = pmax(0, pmin(1, roc_valores)),  # Limitar entre 0 e 1
      stringsAsFactors = FALSE
    ))
  }
}

cat("Dados TSS:", nrow(tss_data), "observaÃ§Ãµes\n")
cat("Dados ROC:", nrow(roc_data), "observaÃ§Ãµes\n")

# CORREÃ‡ÃƒO: Garantir que Modelo seja fator e ordenar
tss_data$Modelo <- as.factor(tss_data$Modelo)
roc_data$Modelo <- as.factor(roc_data$Modelo)

# Ordenar modelos com Ensemble primeiro
niveis_ordenados <- c("Ensemble", "GLM", "GAM", "GBM", "RF", "MAXENT")
tss_data$Modelo <- factor(tss_data$Modelo, levels = niveis_ordenados)
roc_data$Modelo <- factor(roc_data$Modelo, levels = niveis_ordenados)

# CORREÃ‡ÃƒO: MELHOR VISUALIZAÃ‡ÃƒO - Usar boxplot mais destacado
tss_violin <- ggplot(tss_data, aes(x = Modelo, y = Valor, fill = Modelo)) +
  # Violino mais transparente
  geom_violin(alpha = 0.3, trim = TRUE, width = 0.8, color = NA) +
  # Boxplot mais destacado
  geom_boxplot(width = 0.5, alpha = 0.8, outlier.size = 1.5, outlier.color = "red", outlier.shape = 16) +
  # Pontos individuais para melhor visualizaÃ§Ã£o
  geom_jitter(width = 0.1, alpha = 0.5, size = 1, color = "darkgray") +
  # MÃ©dia destacada
  stat_summary(fun = mean, geom = "point", shape = 18, size = 4, color = "black") +
  # Texto com valor mÃ©dio
  stat_summary(fun = mean, geom = "text", aes(label = paste0("MÃ©dia: ", round(..y.., 3))),
               vjust = -2, size = 3, color = "black", fontface = "bold") +
  scale_fill_viridis_d(option = "C", alpha = 0.7) +
  theme_minimal() +
  labs(title = "Desempenho dos Modelos - TSS (True Skill Statistic)",
       x = "Modelo", y = "Valor TSS",
       subtitle = "Quanto mais prÃ³ximo de 1, melhor o desempenho") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
        axis.text.y = element_text(size = 10),
        plot.title = element_text(face = "bold", hjust = 0.5, size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 11),
        legend.position = "none") +
  ylim(0, 1) +
  # Adicionar grade para melhor leitura
  theme(panel.grid.major = element_line(color = "gray90"),
        panel.grid.minor = element_line(color = "gray95"))

# GrÃ¡fico de ROC melhorado
roc_violin <- ggplot(roc_data, aes(x = Modelo, y = Valor, fill = Modelo)) +
  geom_violin(alpha = 0.3, trim = TRUE, width = 0.8, color = NA) +
  geom_boxplot(width = 0.5, alpha = 0.8, outlier.size = 1.5, outlier.color = "red", outlier.shape = 16) +
  geom_jitter(width = 0.1, alpha = 0.5, size = 1, color = "darkgray") +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 4, color = "black") +
  stat_summary(fun = mean, geom = "text", aes(label = paste0("MÃ©dia: ", round(..y.., 3))),
               vjust = -2, size = 3, color = "black", fontface = "bold") +
  scale_fill_viridis_d(option = "C", alpha = 0.7) +
  theme_minimal() +
  labs(title = "Desempenho dos Modelos - ROC (AUC)",
       x = "Modelo", y = "Valor ROC",
       subtitle = "Ãrea sob a curva ROC - Quanto mais prÃ³ximo de 1, melhor") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
        axis.text.y = element_text(size = 10),
        plot.title = element_text(face = "bold", hjust = 0.5, size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 11),
        legend.position = "none") +
  ylim(0, 1) +
  theme(panel.grid.major = element_line(color = "gray90"),
        panel.grid.minor = element_line(color = "gray95"))

# CORREÃ‡ÃƒO ALTERNATIVA: Se ainda estiver muito compacto, usar apenas boxplot
tss_boxplot <- ggplot(tss_data, aes(x = Modelo, y = Valor, fill = Modelo)) +
  geom_boxplot(alpha = 0.8, outlier.size = 2, outlier.color = "red") +
  geom_point(position = position_jitter(width = 0.2), alpha = 0.6, size = 1.5) +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 4, color = "black") +
  scale_fill_viridis_d(option = "C") +
  theme_minimal() +
  labs(title = "Desempenho dos Modelos - TSS (Boxplot)",
       x = "Modelo", y = "TSS") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(face = "bold", hjust = 0.5)) +
  ylim(0, 1)

roc_boxplot <- ggplot(roc_data, aes(x = Modelo, y = Valor, fill = Modelo)) +
  geom_boxplot(alpha = 0.8, outlier.size = 2, outlier.color = "red") +
  geom_point(position = position_jitter(width = 0.2), alpha = 0.6, size = 1.5) +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 4, color = "black") +
  scale_fill_viridis_d(option = "C") +
  theme_minimal() +
  labs(title = "Desempenho dos Modelos - ROC (Boxplot)", 
       x = "Modelo", y = "ROC") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(face = "bold", hjust = 0.5)) +
  ylim(0, 1)

# Salvar ambas as versÃµes
evaluation_plot_violin <- tss_violin / roc_violin +
  plot_annotation(title = "AvaliaÃ§Ã£o de Desempenho dos Modelos (Violino)",
                  theme = theme(plot.title = element_text(face = "bold", size = 16, hjust = 0.5)))

evaluation_plot_boxplot <- tss_boxplot / roc_boxplot +
  plot_annotation(title = "AvaliaÃ§Ã£o de Desempenho dos Modelos (Boxplot)",
                  theme = theme(plot.title = element_text(face = "bold", size = 16, hjust = 0.5)))

# Salvar grÃ¡ficos
ggsave(file.path(output_dir, "03A_Confiabilidade_Modelos_Violino_teste39.png"), 
       evaluation_plot_violin, width = 14, height = 10, dpi = 300)

ggsave(file.path(output_dir, "03B_Confiabilidade_Modelos_Boxplot_teste39.png"), 
       evaluation_plot_boxplot, width = 14, height = 10, dpi = 300)

cat("GrÃ¡ficos de confiabilidade salvos com sucesso!\n")
cat("- 03A_Confiabilidade_Modelos_Violino_teste39.png (versÃ£o violino)\n")
cat("- 03B_Confiabilidade_Modelos_Boxplot_teste39.png (versÃ£o boxplot)\n")

# Mostrar estatÃ­sticas resumidas detalhadas
cat("\nESTATÃSTICAS DETALHADAS DE AVALIAÃ‡ÃƒO:\n")

if (nrow(tss_data) > 0) {
  cat("ðŸ“Š TSS por modelo:\n")
  stats_tss <- tss_data %>% group_by(Modelo) %>% summarise(
    MÃ©dia = round(mean(Valor, na.rm = TRUE), 3),
    Mediana = round(median(Valor, na.rm = TRUE), 3),
    Desvio_PadrÃ£o = round(sd(Valor, na.rm = TRUE), 3),
    MÃ­nimo = round(min(Valor, na.rm = TRUE), 3),
    MÃ¡ximo = round(max(Valor, na.rm = TRUE), 3),
    n = n(),
    .groups = 'drop'
  )
  print(stats_tss)
  
  # Destacar o melhor modelo
  melhor_tss <- stats_tss[which.max(stats_tss$MÃ©dia), ]
  cat("ðŸŽ¯ Melhor modelo TSS:", melhor_tss$Modelo, "- Valor:", melhor_tss$MÃ©dia, "\n")
}

if (nrow(roc_data) > 0) {
  cat("\nðŸ“Š ROC por modelo:\n")
  stats_roc <- roc_data %>% group_by(Modelo) %>% summarise(
    MÃ©dia = round(mean(Valor, na.rm = TRUE), 3),
    Mediana = round(median(Valor, na.rm = TRUE), 3),
    Desvio_PadrÃ£o = round(sd(Valor, na.rm = TRUE), 3),
    MÃ­nimo = round(min(Valor, na.rm = TRUE), 3),
    MÃ¡ximo = round(max(Valor, na.rm = TRUE), 3),
    n = n(),
    .groups = 'drop'
  )
  print(stats_roc)
  
  # Destacar o melhor modelo
  melhor_roc <- stats_roc[which.max(stats_roc$MÃ©dia), ]
  cat("ðŸŽ¯ Melhor modelo ROC:", melhor_roc$Modelo, "- Valor:", melhor_roc$MÃ©dia, "\n")
}

# GrÃ¡fico de comparaÃ§Ã£o direta entre modelos
comparison_plot <- ggplot() +
  geom_point(data = tss_data, aes(x = Modelo, y = Valor, color = "TSS"), 
             position = position_jitter(width = 0.2), alpha = 0.6) +
  geom_point(data = roc_data, aes(x = Modelo, y = Valor, color = "ROC"), 
             position = position_jitter(width = 0.2), alpha = 0.6) +
  stat_summary(data = tss_data, aes(x = Modelo, y = Valor, group = 1), 
               fun = mean, geom = "line", color = "blue", size = 1, linetype = "dashed") +
  stat_summary(data = roc_data, aes(x = Modelo, y = Valor, group = 1), 
               fun = mean, geom = "line", color = "red", size = 1, linetype = "dashed") +
  scale_color_manual(values = c("TSS" = "blue", "ROC" = "red")) +
  theme_minimal() +
  labs(title = "ComparaÃ§Ã£o Direta entre MÃ©tricas",
       x = "Modelo", y = "Valor", color = "MÃ©trica") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggsave(file.path(output_dir, "03C_Comparacao_Direta_Metricas_teste39.png"), 
       comparison_plot, width = 12, height = 8, dpi = 300)

# ============================
# PAINEL FINAL CORRIGIDO - VIOLIN PLOTS AO LADO DOS MAPAS
# ============================

cat("Gerando painel final com violin plots AO LADO dos mapas das variÃ¡veis...\n")

# 1. MAPA DE ADEQUABILIDADE DO ENSEMBLE
ensemble_path <- file.path(output_dir, "ensemble_projection_4layers_teste39.tif")
ensemble_raster <- rast(ensemble_path)

suitability_map <- ggplot() +
  geom_spatraster(data = ensemble_raster) +
  geom_sf(data = countries, fill = NA, color = "black", linewidth = 0.2) +
  geom_point(data = pres_coords, aes(x = lon, y = lat), 
             color = "red", size = 1, alpha = 0.6) +
  scale_fill_viridis_c(option = "plasma", name = "Adequabilidade", na.value = NA) +
  coord_sf(xlim = c(-120, -30), ylim = c(-60, 30)) +
  theme_minimal() +
  labs(
    title = "Mapa de Adequabilidade do Habitat - Ensemble",
    subtitle = "Modelo consensual combinando todos os algoritmos"
  ) +
  theme(plot.title = element_text(face = "bold", hjust = 0.5))

# 2. GRÃFICO DE IMPORTÃ‚NCIA DAS VARIÃVEIS
importance_plot <- ggplot(importance_df, aes(x = reorder(var, importance), y = importance, fill = var)) +
  geom_col(alpha = 0.8) +
  geom_text(aes(label = sprintf("%.3f", importance)), 
            hjust = -0.2, size = 4, fontface = "bold") +
  coord_flip(ylim = c(0, max(importance_df$importance) * 1.2)) +
  scale_fill_viridis_d(option = "C") +
  theme_minimal() +
  labs(
    x = "", 
    y = "ImportÃ¢ncia", 
    title = "ImportÃ¢ncia das VariÃ¡veis Ambientais",
    subtitle = "ContribuiÃ§Ã£o relativa no modelo ensemble"
  ) +
  theme(legend.position = "none")

# 3. DIAGNÃ“STICO DAS VARIÃVEIS AMBIENTAIS - MAPA + VIOLIN PLOT AO LADO
# FunÃ§Ã£o para criar layout mapa + violin plot LADO A LADO
create_variable_side_panel <- function(r, varname, pres_coords, countries, importance_value) {
  
  # Mapa da variÃ¡vel (lado esquerdo)
  map_plot <- ggplot() +
    geom_spatraster(data = r) +
    geom_sf(data = countries, fill = NA, color = "black", linewidth = 0.1) +
    geom_point(data = pres_coords, aes(x = lon, y = lat), 
               color = "red", size = 0.8, alpha = 0.7) +
    scale_fill_viridis_c(option = "viridis", name = varname, na.value = NA) +
    coord_sf(xlim = c(-120, -30), ylim = c(-60, 30)) +
    theme_minimal() +
    labs(
      title = paste("DistribuiÃ§Ã£o Espacial -", varname),
      subtitle = paste("ImportÃ¢ncia no modelo:", round(importance_value, 3))
    ) +
    theme(
      plot.title = element_text(size = 11, face = "bold", hjust = 0.5),
      plot.subtitle = element_text(size = 9, hjust = 0.5),
      legend.position = "right",
      axis.text = element_text(size = 7)
    )
  
  # Violin plot da variÃ¡vel (lado direito)
  # Extrair valores nas presenÃ§as
  vals_presenca <- terra::extract(r, pres_coords[, c("lon", "lat")])[,2]
  vals_presenca <- vals_presenca[!is.na(vals_presenca)]
  
  # Amostrar valores de fundo
  vals_fundo <- sample(values(r)[!is.na(values(r))], 
                       min(600, sum(!is.na(values(r))))) ## antes era 2000, esse Ã© o numero de pontos no "fundo"
  vals_fundo <- vals_fundo[!is.na(vals_fundo)]
  
  # Criar dataframe para o violin plot
  violin_data <- data.frame(
    valor = c(vals_presenca, vals_fundo),
    tipo = c(rep("PresenÃ§a", length(vals_presenca)), 
             rep("Fundo", length(vals_fundo)))
  )
  
  # Calcular estatÃ­sticas para anotaÃ§Ãµes
  stats <- violin_data %>% 
    group_by(tipo) %>% 
    summarise(
      media = mean(valor, na.rm = TRUE),
      mediana = median(valor, na.rm = TRUE),
      n = n()
    )
  
  violin_plot <- ggplot(violin_data, aes(x = tipo, y = valor, fill = tipo)) +
    geom_violin(alpha = 0.7, trim = TRUE, width = 0.8) +
    geom_boxplot(width = 0.10, alpha = 0.7, outlier.size = 0.8) +
    geom_point(position = position_jitter(width = 0.2), alpha = 0.4, size = 1) +
    stat_summary(fun = mean, geom = "point", shape = 23, size = 3, 
                 fill = "white", color = "black") +
    scale_fill_manual(values = c("PresenÃ§a" = "#FF6B6B", "Fundo" = "#4ECDC4")) +
    theme_minimal() +
    labs(
      x = "",
      y = varname,
      title = paste("DistribuiÃ§Ã£o -", varname),
      subtitle = "ComparaÃ§Ã£o: PresenÃ§as vs Ãrea de Fundo"
    ) +
    theme(
      plot.title = element_text(size = 11, face = "bold", hjust = 0.5),
      plot.subtitle = element_text(size = 9, hjust = 0.5),
      legend.position = "none",
      axis.text = element_text(size = 9),
      axis.title.y = element_text(size = 10, face = "bold")
    ) +
    # Adicionar valores mÃ©dios
    geom_text(data = stats, 
              aes(x = tipo, y = max(violin_data$valor, na.rm = TRUE) * 1.05,
              label = paste0("MÃ©dia: ", round(media, 2), "\nN: ", n)),
              inherit.aes = FALSE,
              size = 3, fontface = "bold", color = "black")
  
  # Combinar mapa e violin plot LADO A LADO
  side_by_side_plot <- map_plot | violin_plot
  
  return(side_by_side_plot)
}

# Criar painÃ©is individuais para cada variÃ¡vel (mapa + violin lado a lado)
variable_side_panels <- list()
for (i in 1:length(names(env_stack_4layers))) {
  varname <- names(env_stack_4layers)[i]
  importance_value <- importance_df$importance[importance_df$var == varname]
  r <- env_stack_4layers[[varname]]
  
  variable_side_panels[[varname]] <- create_variable_side_panel(
    r, varname, pres_coords, countries, importance_value
  )
}

# Combinar todos os painÃ©is de variÃ¡veis em grid 2x2 (cada cÃ©lula contÃ©m mapa + violin)
variables_grid_side <- wrap_plots(variable_side_panels, ncol = 2, nrow = 2) +
  plot_annotation(
    title = "AnÃ¡lise das VariÃ¡veis Ambientais: Mapas e DistribuiÃ§Ãµes",
    subtitle = "Cada variÃ¡vel mostra o mapa espacial (esquerda) e distribuiÃ§Ã£o presenÃ§as vs fundo (direita)",
    theme = theme(
      plot.title = element_text(face = "bold", hjust = 0.5, size = 16),
      plot.subtitle = element_text(hjust = 0.5, size = 12)
    )
  )

# 4. VIOLIN PLOTS DE CONFIABILIDADE DOS MODELOS (compactos)
# ======================================================
# AVALIAÃ‡ÃƒO REAL DOS MODELOS (BIOMOD2) - VIOLIN PLOTS
# ======================================================

library(biomod2)
library(terra)
library(dplyr)
library(ggplot2)
library(viridis)
library(patchwork)

# ------------------------------------------------------
# EXTRAIR AVALIAÃ‡Ã•ES REAIS DOS MODELOS
# ------------------------------------------------------
cat("Extraindo mÃ©tricas TSS e ROC dos modelos...\n")

# Certifique-se de ter carregado os objetos previamente:
# models_4layers <- readRDS(".../models_4layers_teste39.rds")
# ensemble_4layers <- readRDS(".../ensemble_4layers_teste39.rds")

model_evals <- get_evaluations(models_4layers)

# Caso o get_evaluations retorne um data.frame (estrutura moderna)
# Ele deve conter as colunas: algo, metric.eval e validation

# ------------------------------------------------------
# PREPARAR OS DADOS PARA PLOTAGEM
# ------------------------------------------------------
# Filtra apenas as mÃ©tricas TSS e ROC, que sÃ£o as que nos interessam
combined_data <- model_evals %>%
  filter(metric.eval %in% c("TSS", "ROC")) %>%
  select(Modelo = algo, MÃ©trica = metric.eval, Valor = validation) %>%
  filter(!is.na(Valor)) %>%
  mutate(
    Modelo = factor(Modelo, levels = c("GLM", "GAM", "GBM", "RF", "MAXENT")),
    MÃ©trica = factor(MÃ©trica, levels = c("TSS", "ROC"))
  )

cat("âœ… MÃ©tricas combinadas extraÃ­das com sucesso.\n")
print(head(combined_data))

# ------------------------------------------------------
# ADICIONAR AVALIAÃ‡ÃƒO DO ENSEMBLE
# ------------------------------------------------------
ensemble_evals <- get_evaluations(ensemble_4layers)

ensemble_tss <- tryCatch({
  as.numeric(ensemble_evals["TSS", "Testing.data", , , "EMmean"])
}, error = function(e) NA)

ensemble_roc <- tryCatch({
  as.numeric(ensemble_evals["ROC", "Testing.data", , , "EMmean"])
}, error = function(e) NA)

ensemble_data <- data.frame(
  Modelo = "Ensemble",
  MÃ©trica = c("TSS", "ROC"),
  Valor = c(ensemble_tss, ensemble_roc)
)

# Juntar ensemble com os outros modelos
combined_data <- rbind(combined_data, ensemble_data)

# ------------------------------------------------------
# FUNÃ‡ÃƒO PARA CRIAR OS VIOLIN PLOTS COMPACTOS
# ------------------------------------------------------
create_compact_evaluation_plot <- function(data, metric) {
  plot_data <- data %>% filter(MÃ©trica == metric)
  
  stats <- plot_data %>% 
    group_by(Modelo) %>% 
    summarise(media = mean(Valor, na.rm = TRUE))
  
  ggplot(plot_data, aes(x = Modelo, y = Valor, fill = Modelo)) +
    geom_violin(alpha = 0.7, trim = TRUE, width = 0.8) +
    geom_boxplot(width = 0.2, alpha = 0.9, outlier.size = 1) +
    geom_jitter(width = 0.1, alpha = 0.4, size = 1) +
    stat_summary(fun = mean, geom = "point", shape = 23, size = 2.5,
                 fill = "white", color = "black") +
    scale_fill_viridis_d(option = "magma", alpha = 0.8) +
    theme_minimal() +
    labs(
      title = paste("Desempenho dos Modelos -", metric),
      x = "Modelo",
      y = paste("Valor", metric)
    ) +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
      axis.text.y = element_text(size = 10),
      plot.title = element_text(face = "bold", hjust = 0.5, size = 12),
      legend.position = "none"
    ) +
    ylim(0, 1) +
    geom_text(data = stats,
              aes(x = Modelo, y = 0.05, label = sprintf("%.3f", media)),
              vjust = -0.5, size = 3.5, fontface = "bold", color = "black")
}

# ------------------------------------------------------
# CRIAR E COMBINAR OS GRÃFICOS
# ------------------------------------------------------
tss_compact <- create_compact_evaluation_plot(combined_data, "TSS")
roc_compact <- create_compact_evaluation_plot(combined_data, "ROC")

evaluation_side <- tss_compact | roc_compact +
  plot_annotation(
    title = "AvaliaÃ§Ã£o da Confiabilidade dos Modelos (TSS e ROC)",
    theme = theme(plot.title = element_text(face = "bold", hjust = 0.5, size = 14))
  )

print(evaluation_side)

# ------------------------------------------------------
# SALVAR O RESULTADO
# ------------------------------------------------------
output_dir <- "C:/Users/Administrador/Desktop/GAB/Mod/Resultados_teste39_ensemble"

if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)

ggsave(file.path(output_dir, "AvaliaÃ§Ã£o_Compacta_TSS_ROC_teste39.png"),
       evaluation_side, width = 12, height = 6, dpi = 300)

cat("âœ… GrÃ¡fico salvo com sucesso em:", output_dir, "\n")


# 5. PAINEL FINAL CORRIGIDO - LAYOUT ORGANIZADO
# Estrutura:
# Linha 1: [Mapa Adequabilidade] + [ImportÃ¢ncia VariÃ¡veis]
# Linha 2: [VariÃ¡vel 1: Mapa | Violin]   [VariÃ¡vel 2: Mapa | Violin]
# Linha 3: [VariÃ¡vel 3: Mapa | Violin]   [VariÃ¡vel 4: Mapa | Violin]  
# Linha 4: [AvaliaÃ§Ã£o TSS | AvaliaÃ§Ã£o ROC]

final_panel_corrigido <- (suitability_map | importance_plot) / 
  variables_grid_side / 
  evaluation_side +
  plot_annotation(
    title = "RELATÃ“RIO COMPLETO - MODELAGEM DE NICHO ECOLÃ“GICO",
    subtitle = "Vampyrum spectrum - AnÃ¡lise Integrada com VisualizaÃ§Ã£o Otimizada",
    caption = paste("Gerado em", format(Sys.Date(), "%d/%m/%Y"),
                   "| Layout: Mapa + Violin Plot lado a lado para cada variÃ¡vel"),
    theme = theme(
      plot.title = element_text(face = "bold", size = 20, hjust = 0.5),
      plot.subtitle = element_text(size = 16, hjust = 0.5),
      plot.caption = element_text(size = 10, hjust = 1)
    )
  )

# Salvar painel final corrigido
ggsave(file.path(output_dir, "04_Painel_Final_Corrigido_LadoaLado_teste39.png"), 
       final_panel_corrigido, width = 22, height = 24, dpi = 300)

# 6. VERSÃƒO ALTERNATIVA - LAYOUT MAIS COMPACTO
# Para variÃ¡veis com menos detalhes nos mapas
create_compact_variable_panel <- function(r, varname, pres_coords, countries, importance_value) {
  
  # Mapa mais compacto
  map_compact <- ggplot() +
    geom_spatraster(data = r) +
    geom_sf(data = countries, fill = NA, color = "black", linewidth = 0.05) +
    geom_point(data = pres_coords, aes(x = lon, y = lat), 
               color = "red", size = 0.3, alpha = 0.6) +
    scale_fill_viridis_c(option = "viridis", name = NULL, na.value = NA) +
    coord_sf(xlim = c(-120, -30), ylim = c(-60, 30)) +
    theme_minimal() +
    labs(title = paste(varname, "\nImp:", round(importance_value, 3))) +
    theme(
      plot.title = element_text(size = 9, face = "bold", hjust = 0.5),
      legend.position = "right",
      axis.text = element_text(size = 6),
      legend.key.height = unit(0.3, "cm")
    )
  
  # Violin plot compacto
  vals_presenca <- terra::extract(r, pres_coords[, c("lon", "lat")])[,2]
  vals_presenca <- vals_presenca[!is.na(vals_presenca)]
  vals_fundo <- sample(values(r)[!is.na(values(r))], 1000)
  vals_fundo <- vals_fundo[!is.na(vals_fundo)]
  
  violin_data <- data.frame(
    valor = c(vals_presenca, vals_fundo),
    tipo = c(rep("PresenÃ§a", length(vals_presenca)), rep("Fundo", length(vals_fundo)))
  )
  
  violin_compact <- ggplot(violin_data, aes(x = tipo, y = valor, fill = tipo)) +
    geom_violin(alpha = 0.7, trim = TRUE, width = 0.6) +
    geom_boxplot(width = 0.1, alpha = 0.9, outlier.size = 0.5) +
    scale_fill_manual(values = c("PresenÃ§a" = "#FF6B6B", "Fundo" = "#4ECDC4")) +
    theme_minimal() +
    labs(x = "", y = "") +
    theme(
      legend.position = "none",
      axis.text = element_text(size = 7),
      plot.margin = margin(2, 2, 2, 2, "mm")
    )
  
  return(map_compact | violin_compact)
}

# Criar versÃ£o compacta
compact_panels <- list()
for (i in 1:length(names(env_stack_4layers))) {
  varname <- names(env_stack_4layers)[i]
  importance_value <- importance_df$importance[importance_df$var == varname]
  r <- env_stack_4layers[[varname]]
  
  compact_panels[[varname]] <- create_compact_variable_panel(
    r, varname, pres_coords, countries, importance_value
  )
}

compact_grid <- wrap_plots(compact_panels, ncol = 2, nrow = 2) +
  plot_annotation(title = "VariÃ¡veis Ambientais (VersÃ£o Compacta)")

# Painel compacto final
final_panel_compacto <- (suitability_map | importance_plot) / 
  compact_grid / 
  evaluation_side +
  plot_annotation(
    title = "AnÃ¡lise Compacta - Vampyrum spectrum",
    theme = theme(plot.title = element_text(face = "bold", hjust = 0.5))
  )

ggsave(file.path(output_dir, "04B_Painel_Compacto_LadoaLado_teste39.png"), 
       final_panel_compacto, width = 18, height = 20, dpi = 300)

# 7. SALVAR PAINÃ‰IS INDIVIDUAIS DAS VARIÃVEIS
cat("Salvando painÃ©is individuais das variÃ¡veis (mapa + violin lado a lado)...\n")

for (varname in names(variable_side_panels)) {
  ggsave(file.path(output_dir, paste0("05_Painel_", varname, "_LadoaLado_teste39.png")), 
         variable_side_panels[[varname]], width = 16, height = 8, dpi = 300)
}

# 8. RELATÃ“RIO FINAL
cat("\n", rep("=", 70), "\n")
cat("RELATÃ“RIO FINAL - CORREÃ‡ÃƒO APLICADA: VIOLIN PLOTS AO LADO DOS MAPAS\n")
cat(rep("=", 70), "\n\n")

cat("âœ“ CORREÃ‡ÃƒO CONCLUÃDA: Violin plots posicionados AO LADO dos mapas\n")
cat("âœ“ LAYOUT OTIMIZADO:\n")
cat("  â€¢ Esquerda: Mapa espacial da variÃ¡vel\n") 
cat("  â€¢ Direita: Violin plot da distribuiÃ§Ã£o (presenÃ§as vs fundo)\n")
cat("  â€¢ Grid 2x2 para as 4 variÃ¡veis ambientais\n")
cat("  â€¢ VisualizaÃ§Ã£o mais equilibrada e comparÃ¡vel\n\n")

cat("âœ“ ESTRUTURA DO PAINEL FINAL:\n")
cat("  1. LINHA 1: Mapa de adequabilidade + ImportÃ¢ncia das variÃ¡veis\n")
cat("  2. LINHA 2-3: Grid 2x2 com [Mapa | Violin] para cada variÃ¡vel\n")
cat("  3. LINHA 4: AvaliaÃ§Ã£o dos modelos [TSS | ROC]\n\n")

cat("ARQUIVOS GERADOS:\n")
cat("- 04_Painel_Final_Corrigido_LadoaLado_teste39.png (painel completo)\n")
cat("- 04B_Painel_Compacto_LadoaLado_teste39.png (versÃ£o compacta)\n")
cat("- 05_Painel_*_LadoaLado_teste39.png (painÃ©is individuais das variÃ¡veis)\n\n")

cat("VISUALIZAÃ‡ÃƒO DAS VARIÃVEIS:\n")
for(varname in names(env_stack_4layers)) {
  cat(sprintf("  â€¢ %s: Mapa espacial + DistribuiÃ§Ã£o presenÃ§as/fundo\n", varname))
}

cat("\n", rep("=", 70), "\n")
cat("LAYOUT CORRIGIDO COM SUCESSO! âœ…\n")
cat("Violin plots agora estÃ£o AO LADO dos mapas das variÃ¡veis\n")
cat(rep("=", 70), "\n")
