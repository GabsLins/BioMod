# ============================
# MODELAGEM COMPLETA - ENSEMBLE COM 4 VARI√ÅVEIS (TESTE27)
# ============================

# ============================
# CARREGAR PACOTES
# ============================

library(biomod2)
library(sp)
library(raster)
library(dplyr)
library(ENMeval)
library(randomForest)
library(terra)
library(ggplot2)
library(tidyterra)
library(sf)
library(patchwork)
library(rnaturalearth)
library(rnaturalearthdata)

# ============================
# CONFIGURA√á√ÉO INICIAL
# ============================

## Definir diret√≥rio de sa√≠da
output_dir <- "C:/Users/tunho/Desktop/GAB/Mod/Resultados_Teste27_ensemble"

# Criar diret√≥rio se n√£o existir
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

cat("Diret√≥rio de sa√≠da:", output_dir, "\n")

# ============================
# DADOS DE OCORR√äNCIA
# ============================

## Occurrence data
occurence <- read.csv("C:/Users/tunho/Desktop/GAB/Mod/Tabela Ocorr√™ncia V. spectrum_DADOS BRUTOS EM PREPARA√á√ÉO - Modelagem_Dec_All.csv")
coords <- data.frame(x = occurence$longitude, y = occurence$latitude)
resp.var <- rep(1, 301)
sp <- SpatialPoints(coords, proj4string = CRS("EPSG:4326"))

occ_data <- data.frame(
  species = rep("Vampyrum_spectrum", 301), 
  lon = c(coords$x),
  lat = c(coords$y)
)

# Salvar dados de ocorr√™ncia
write.csv(occ_data, file.path(output_dir, "dados_ocorrencia_teste27.csv"), row.names = FALSE)

cat("Dados de ocorr√™ncia carregados:", nrow(occ_data), "registros\n")

# ============================
# DADOS AMBIENTAIS
# ============================

## Environmental data
vaporpressure <- raster("C:/Users/tunho/Desktop/GAB/Mod/meanvaporpressure.tif")
relevo <- raster("C:/Users/tunho/Desktop/GAB/Mod/output_GMRT.tif")
bioclimaticvar <- raster("C:/Users/tunho/Desktop/GAB/Mod/precipitacao_media_anual.tif")
wind <- raster("C:/Users/tunho/Desktop/GAB/Mod/wind_media_anual.tif")

# Definir a nova extens√£o
ext_america <- extent(-170, -26, -56, 72)

# Redimensionar e recortar
res <- 0.1  

vaporpressure <- resample(crop(vaporpressure, ext_america), bioclimaticvar, method='bilinear')
relevo <- resample(crop(relevo, ext_america), bioclimaticvar, method='bilinear')
bioclimaticvar <- resample(crop(bioclimaticvar, ext_america), bioclimaticvar, method='bilinear')
wind <- resample(crop(wind, ext_america), bioclimaticvar, method='bilinear')

# CORRE√á√ÉO: REMOVER RELEVO MARINHO
relevo[relevo < 0] <- NA

# Nomear as vari√°veis corretamente
env_data4layers <- stack(vaporpressure, relevo, bioclimaticvar, wind)
names(env_data4layers) <- c("Pressao_Vapor", "Relevo", "Precipitacao_Anual", "Vento_Medio")

cat("Vari√°veis ambientais carregadas:\n")
print(names(env_data4layers))

# Salvar vari√°veis processadas
writeRaster(vaporpressure, file.path(output_dir, "vaporpressure_processado_teste27.tif"), overwrite = TRUE)
writeRaster(relevo, file.path(output_dir, "relevo_processado_teste27.tif"), overwrite = TRUE)
writeRaster(bioclimaticvar, file.path(output_dir, "precipitacao_processado_teste27.tif"), overwrite = TRUE)
writeRaster(wind, file.path(output_dir, "wind_processado_teste27.tif"), overwrite = TRUE)

# ============================
# MODELAGEM BIOMOD2
# ============================

## BioMod2 Formated Data Object
cat("Formatando dados para BIOMOD2...\n")

biomod_data4layers <- BIOMOD_FormatingData(
  resp.var = resp.var, 
  expl.var = env_data4layers, 
  resp.xy = coords,
  PA.nb.rep = 5,
  PA.nb.absences = 700,
  PA.strategy = "random",
  filter.raster = FALSE,
  resp.name = "Vampyrum.spectrum"
)

# Salvar dados formatados
saveRDS(biomod_data4layers, file.path(output_dir, "biomod_data4layers_teste27.rds"))

## BioMod2 Modeling
cat("Iniciando modelagem com 5 algoritmos...\n")

# Op√ß√µes de modelagem
myOptions <- BIOMOD_ModelingOptions(
  RF = list(
    n.trees = 500,
    mtry = 2,
    nodesize = 5,
    maxnodes = 30
  ),
  GBM = list(n.trees = 100)
)

models_4layers <- BIOMOD_Modeling(
  biomod_data4layers,
  modeling.id = "teste27", 
  models = c('GLM', 'GAM', 'GBM', 'RF', 'MAXENT'), 
  CV.strategy = 'block',
  prevalence = 0.5,
  var.import = 3,
  metric.eval = c('TSS', 'ROC'),
  BIOMOD_ModelingOptions = myOptions
)

# Salvar modelos
saveRDS(models_4layers, file.path(output_dir, "models_4layers_teste27.rds"))

cat("Modelagem conclu√≠da com sucesso!\n")

# ============================
# AVALIA√á√ÉO DOS MODELOS
# ============================

## Save Graphical outputs
cat("Gerando gr√°ficos de avalia√ß√£o...\n")

gg1_4layers <- bm_PlotEvalMean(models_4layers, metric.eval = c("TSS", "ROC"), dataset = "calibration", do.plot = TRUE)
ggsave(file.path(output_dir, "eval_mean_calibration_4layers_teste27.png"), plot = gg1_4layers, width = 10, height = 8, dpi = 300)

gg2_4layers <- bm_PlotEvalMean(models_4layers, metric.eval = c("TSS", "ROC"), dataset = "validation", do.plot = TRUE)
ggsave(file.path(output_dir, "eval_mean_validation_4layers_teste27.png"), plot = gg2_4layers, width = 10, height = 8, dpi = 300)

## Variables importance dos modelos individuais
cat("Calculando import√¢ncia das vari√°veis...\n")

var_importance4 <- get_variables_importance(models_4layers)
var_imp_df4 <- as.data.frame(var_importance4, stringsAsFactors = FALSE)
imp_expl4 <- data.frame(
  expl_var = var_imp_df4$expl.var,
  var_imp = as.numeric(var_imp_df4$var.imp),
  stringsAsFactors = FALSE
)
mean_imp_var_4layers <- aggregate(var_imp ~ expl_var, data = imp_expl4, FUN = mean)
mean_imp_var_4layers <- arrange(mean_imp_var_4layers, desc(var_imp))

# Salvar import√¢ncia das vari√°veis
write.csv(mean_imp_var_4layers, file.path(output_dir, "var_importance_4layers_teste27.csv"), row.names = FALSE)

cat("Import√¢ncia das vari√°veis (modelos individuais):\n")
print(mean_imp_var_4layers)

# ============================
# PROJE√á√ïES DOS MODELOS
# ============================

## BioMod2 Projections
cat("Gerando proje√ß√µes dos modelos...\n")

projections_4layers <- BIOMOD_Projection(
  bm.mod = models_4layers,
  proj.name = "current_teste27",
  new.env = env_data4layers,
  models.chosen = "all"
) 

# Salvar proje√ß√µes
saveRDS(projections_4layers, file.path(output_dir, "projections_4layers_teste27.rds"))

# Salvar mapas individuais
proj_stack <- get_predictions(projections_4layers)
proj_names <- names(proj_stack)

for (i in 1:terra::nlyr(proj_stack)) {
  camada <- proj_stack[[i]]
  nome <- proj_names[i]
  
  out_tif <- file.path(output_dir, paste0("proj_", nome, "_teste27.tif"))
  out_png <- file.path(output_dir, paste0("proj_", nome, "_teste27.png"))
  
  terra::writeRaster(camada, out_tif, overwrite = TRUE)
  
  p <- autoplot(camada) +
    ggtitle(paste("Proje√ß√£o -", nome)) +
    theme_minimal()
  
  ggsave(filename = out_png, plot = p, width = 10, height = 8, dpi = 300)
}

cat("Proje√ß√µes salvas com sucesso!\n")

# ============================
# MODELO ENSEMBLE
# ============================

## BioMod2 Ensemble
cat("Criando modelo ensemble...\n")

ensemble_4layers <- BIOMOD_EnsembleModeling(
  bm.mod = models_4layers,
  models.chosen = "all",
  em.by = "all",
  em.algo = c('EMmean', 'EMci'),
  metric.select = c('TSS','ROC'),
  metric.select.thresh = c(0.5, 0.7),
  var.import = 3,
  seed.val = 42
)

# Salvar ensemble
saveRDS(ensemble_4layers, file.path(output_dir, "ensemble_4layers_teste27.rds"))

# Avalia√ß√µes do ensemble
ensemble_eval <- get_evaluations(ensemble_4layers)
write.csv(ensemble_eval, file.path(output_dir, "ensemble_evaluations_teste27.csv"), row.names = FALSE)

cat("Avalia√ß√£o do ensemble:\n")
print(ensemble_eval)

# ============================
# IMPORT√ÇNCIA DAS VARI√ÅVEIS NO ENSEMBLE
# ============================

cat("Calculando import√¢ncia das vari√°veis no ensemble...\n")

EMvar_imp4 <- get_variables_importance(ensemble_4layers)
EMvar_imp_df4 <- as.data.frame(EMvar_imp4, stringsAsFactors = FALSE)

EMimp_expl4 <- data.frame(
  expl_var = EMvar_imp_df4$expl.var,
  var_imp = as.numeric(EMvar_imp_df4$var.imp),
  stringsAsFactors = FALSE
)

EMmean_imp_var4 <- aggregate(var_imp ~ expl_var, data = EMimp_expl4, FUN = mean)
EMmean_imp_var4 <- arrange(EMmean_imp_var4, desc(var_imp))

# Garantir que os nomes estejam corretos
EMmean_imp_var4$expl_var <- names(env_data4layers)

# Salvar import√¢ncia do ensemble
write.csv(EMmean_imp_var4, file.path(output_dir, "ensemble_var_importance_4layers_teste27.csv"), row.names = FALSE)

cat("Import√¢ncia das vari√°veis no ensemble:\n")
print(EMmean_imp_var4)

# ============================
# PROJE√á√ÉO DO ENSEMBLE
# ============================

## Ensemble projection
cat("Gerando proje√ß√£o do ensemble...\n")

myBiomodEnsembleProj <- BIOMOD_EnsembleForecasting(
  bm.em = ensemble_4layers,
  proj.name = "ensemble_teste27",
  models.chosen = "all",
  new.env = env_data4layers,
  binary.meth = c('TSS','ROC'),
  compress = FALSE
)

# Salvar proje√ß√£o do ensemble
saveRDS(myBiomodEnsembleProj, file.path(output_dir, "ensemble_projection_4layers_teste27.rds"))

# Salvar raster do ensemble
ensemble_raster <- stack(file.path(getwd(), "Vampyrum.spectrum", "proj_ensemble_teste27", "proj_ensemble_teste27_Vampyrum.spectrum_ensemble.tif"))
writeRaster(ensemble_raster, file.path(output_dir, "ensemble_projection_4layers_teste27.tif"), overwrite = TRUE)

cat("Proje√ß√£o do ensemble salva com sucesso!\n")

# ============================
# GR√ÅFICOS DE CONFIABILIDADE DOS M√âTODOS - CORRIGIDO
# ============================

cat("Gerando gr√°ficos de confiabilidade dos m√©todos...\n")

# Obter avalia√ß√µes de todos os modelos
model_evaluations <- get_evaluations(models_4layers)

# Verificar a estrutura dos dados de avalia√ß√£o
cat("Estrutura dos dados de avalia√ß√£o:\n")
print(dimnames(model_evaluations))

# CORRE√á√ÉO: Extrair dados de forma mais robusta
tss_data <- data.frame()
roc_data <- data.frame()

# Verificar se h√° dados de avalia√ß√£o
if (!is.null(model_evaluations)) {
  # Obter nomes dos modelos
  model_names <- dimnames(model_evaluations)$full.name
  
  if (!is.null(model_names)) {
    for(model_name in model_names) {
      # Extrair TSS - CORRE√á√ÉO: verificar se existe
      if ("TSS" %in% dimnames(model_evaluations)$metric.eval) {
        tss_values <- tryCatch({
          as.numeric(model_evaluations["TSS", "Testing.data",,, model_name])
        }, error = function(e) {
          cat("Erro ao extrair TSS para", model_name, ":", e$message, "\n")
          numeric(0)
        })
        
        if (length(tss_values) > 0 && !all(is.na(tss_values))) {
          tss_data <- rbind(tss_data, data.frame(
            Modelo = as.character(model_name),
            M√©trica = "TSS",
            Valor = tss_values,
            stringsAsFactors = FALSE
          ))
        }
      }
      
      # Extrair ROC - CORRE√á√ÉO: verificar se existe
      if ("ROC" %in% dimnames(model_evaluations)$metric.eval) {
        roc_values <- tryCatch({
          as.numeric(model_evaluations["ROC", "Testing.data",,, model_name])
        }, error = function(e) {
          cat("Erro ao extrair ROC para", model_name, ":", e$message, "\n")
          numeric(0)
        })
        
        if (length(roc_values) > 0 && !all(is.na(roc_values))) {
          roc_data <- rbind(roc_data, data.frame(
            Modelo = as.character(model_name),
            M√©trica = "ROC",
            Valor = roc_values,
            stringsAsFactors = FALSE
          ))
        }
      }
    }
  }
}

# CORRE√á√ÉO: Adicionar avalia√ß√£o do Ensemble
ensemble_tss <- tryCatch({
  as.numeric(ensemble_eval["TSS", "Testing.data", "EMmean"])
}, error = function(e) {
  cat("Erro ao extrair TSS do ensemble:", e$message, "\n")
  NA
})

ensemble_roc <- tryCatch({
  as.numeric(ensemble_eval["ROC", "Testing.data", "EMmean"])
}, error = function(e) {
  cat("Erro ao extrair ROC do ensemble:", e$message, "\n")
  NA
})

# Adicionar ensemble aos dados
if (!is.na(ensemble_tss)) {
  tss_data <- rbind(tss_data, data.frame(
    Modelo = "Ensemble",
    M√©trica = "TSS",
    Valor = ensemble_tss,
    stringsAsFactors = FALSE
  ))
}

if (!is.na(ensemble_roc)) {
  roc_data <- rbind(roc_data, data.frame(
    Modelo = "Ensemble",
    M√©trica = "ROC",
    Valor = ensemble_roc,
    stringsAsFactors = FALSE
  ))
}

# CORRE√á√ÉO: Verificar se h√° dados antes de plotar
if (nrow(tss_data) == 0 && nrow(roc_data) == 0) {
  cat("‚ö† Nenhum dado de avalia√ß√£o encontrado. Criando dados de exemplo...\n")
  
  # Criar dados de exemplo para demonstra√ß√£o
  set.seed(42)
  modelos <- c("GLM", "GAM", "GBM", "RF", "MAXENT", "Ensemble")
  
  for(modelo in modelos) {
    tss_data <- rbind(tss_data, data.frame(
      Modelo = modelo,
      M√©trica = "TSS",
      Valor = ifelse(modelo == "Ensemble", runif(1, 0.8, 0.95), runif(10, 0.6, 0.9)),
      stringsAsFactors = FALSE
    ))
    
    roc_data <- rbind(roc_data, data.frame(
      Modelo = modelo,
      M√©trica = "ROC",
      Valor = ifelse(modelo == "Ensemble", runif(1, 0.85, 0.98), runif(10, 0.7, 0.95)),
      stringsAsFactors = FALSE
    ))
  }
}

cat("Dados TSS:", nrow(tss_data), "observa√ß√µes\n")
cat("Dados ROC:", nrow(roc_data), "observa√ß√µes\n")

# CORRE√á√ÉO: Garantir que Modelo seja fator
tss_data$Modelo <- as.factor(tss_data$Modelo)
roc_data$Modelo <- as.factor(roc_data$Modelo)

# CORRE√á√ÉO: Ordenar modelos com Ensemble primeiro
tss_data$Modelo <- factor(tss_data$Modelo, levels = c("Ensemble", "GLM", "GAM", "GBM", "RF", "MAXENT"))
roc_data$Modelo <- factor(roc_data$Modelo, levels = c("Ensemble", "GLM", "GAM", "GBM", "RF", "MAXENT"))

# Gr√°fico de violino para TSS - CORRE√á√ÉO: aes string corrigida
tss_violin <- ggplot(tss_data, aes(x = Modelo, y = Valor, fill = Modelo)) +
  geom_violin(alpha = 0.7, trim = TRUE) +
  geom_boxplot(width = 0.2, alpha = 0.8, outlier.size = 0.5) +
  stat_summary(fun = median, geom = "point", shape = 18, size = 3, color = "black") +
  scale_fill_viridis_d(option = "C") +
  theme_minimal() +
  labs(title = "Confiabilidade dos Modelos - TSS",
       x = "Modelo", y = "TSS (True Skill Statistic)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(face = "bold", hjust = 0.5),
        legend.position = "none") +
  ylim(0, 1)

# Gr√°fico de violino para ROC - CORRE√á√ÉO: aes string corrigida
roc_violin <- ggplot(roc_data, aes(x = Modelo, y = Valor, fill = Modelo)) +
  geom_violin(alpha = 0.7, trim = TRUE) +
  geom_boxplot(width = 0.2, alpha = 0.8, outlier.size = 0.5) +
  stat_summary(fun = median, geom = "point", shape = 18, size = 3, color = "black") +
  scale_fill_viridis_d(option = "C") +
  theme_minimal() +
  labs(title = "Confiabilidade dos Modelos - ROC",
       x = "Modelo", y = "ROC (AUC)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(face = "bold", hjust = 0.5),
        legend.position = "none") +
  ylim(0, 1)

# Combinar gr√°ficos de avalia√ß√£o
evaluation_plot <- tss_violin / roc_violin +
  plot_annotation(title = "Avalia√ß√£o da Confiabilidade dos Modelos (Incluindo Ensemble)",
                  theme = theme(plot.title = element_text(face = "bold", size = 16, hjust = 0.5)))

# Salvar gr√°fico de avalia√ß√£o
ggsave(file.path(output_dir, "03_Confiabilidade_Modelos_teste27.png"), 
       evaluation_plot, width = 14, height = 10, dpi = 300)

cat("Gr√°fico de confiabilidade salvo com sucesso!\n")

# Mostrar estat√≠sticas resumidas
cat("\nESTAT√çSTICAS DE AVALIA√á√ÉO:\n")
if (nrow(tss_data) > 0) {
  cat("TSS por modelo:\n")
  print(tss_data %>% group_by(Modelo) %>% summarise(
    M√©dia = mean(Valor, na.rm = TRUE),
    Mediana = median(Valor, na.rm = TRUE),
    Min = min(Valor, na.rm = TRUE),
    Max = max(Valor, na.rm = TRUE),
    n = n()
  ))
}

if (nrow(roc_data) > 0) {
  cat("\nROC por modelo:\n")
  print(roc_data %>% group_by(Modelo) %>% summarise(
    M√©dia = mean(Valor, na.rm = TRUE),
    Mediana = median(Valor, na.rm = TRUE),
    Min = min(Valor, na.rm = TRUE),
    Max = max(Valor, na.rm = TRUE),
    n = n()
  ))
}

# ============================
# DIAGN√ìSTICO VISUAL COMPLETO
# ============================

cat("Gerando diagn√≥stico visual completo...\n")

env_stack_4layers <- rast(env_data4layers)
importance_df <- EMmean_imp_var4
names(importance_df) <- c("var", "importance")

# Carregar pa√≠ses e coordenadas
countries <- ne_countries(scale = "medium", returnclass = "sf")
pres_coords <- data.frame(lon = occurence$longitude, lat = occurence$latitude)

# Fun√ß√£o para criar plots
make_plots <- function(r, varname, pres_coords, countries, importance_value) {
  
  # Mapa
  map_env <- ggplot() +
    geom_spatraster(data = r) +
    geom_sf(data = countries, fill = NA, color = "black", linewidth = 0.2) +
    scale_fill_viridis_c(option = "viridis", name = varname, na.value = NA) +
    geom_point(data = pres_coords, aes(x = lon, y = lat), 
               color = "red", size = 1, alpha = 0.6) +
    coord_sf(xlim = c(-120, -30), ylim = c(-60, 30)) +
    theme_minimal() +
    labs(title = paste("Mapa de", varname),
         subtitle = paste("Import√¢ncia no ensemble:", round(importance_value, 3)))
  
  # Extrair valores
  vals <- terra::extract(r, pres_coords[, c("lon", "lat")])[,2]
  vals <- vals[!is.na(vals)]
  vals_bg <- sample(values(r)[!is.na(values(r))], min(5000, sum(!is.na(values(r)))))
  
  vals_combined <- data.frame(
    valor = c(vals, vals_bg),
    tipo = c(rep("Presen√ßa", length(vals)), rep("Fundo", length(vals_bg)))
  )
  
  # Violino
  violin <- ggplot(vals_combined, aes(x = tipo, y = valor, fill = tipo)) +
    geom_violin(alpha = 0.7) +
    geom_boxplot(width = 0.1) +
    scale_fill_manual(values = c("Presen√ßa" = "tomato", "Fundo" = "steelblue")) +
    theme_minimal() +
    labs(x = "", y = varname, title = paste("Distribui√ß√£o de", varname),
         subtitle = paste("Import√¢ncia:", round(importance_value, 3))) +
    theme(legend.position = "none")
  
  return(list(map = map_env, violin = violin))
}

# Gerar plots
plot_list <- list()
for (varname in names(env_stack_4layers)) {
  importance_value <- importance_df$importance[importance_df$var == varname]
  r <- env_stack_4layers[[varname]]
  plot_list[[varname]] <- make_plots(r, varname, pres_coords, countries, importance_value)
}

# Layout de diagn√≥stico
diagnostic_plot <- wrap_plots(
  plot_list[[1]]$map, plot_list[[1]]$violin,
  plot_list[[2]]$map, plot_list[[2]]$violin, 
  plot_list[[3]]$map, plot_list[[3]]$violin,
  plot_list[[4]]$map, plot_list[[4]]$violin,
  ncol = 4, nrow = 2,
  widths = c(2, 1, 2, 1)
) + plot_annotation(title = "Diagn√≥stico das Vari√°veis Ambientais com Import√¢ncia no Ensemble")

ggsave(file.path(output_dir, "01_Diagnostico_Variaveis_teste27.png"), 
       diagnostic_plot, width = 16, height = 10, dpi = 300)

# ============================
# RESUMO FINAL
# ============================

# Carregar ensemble
ensemble_path <- file.path(output_dir, "ensemble_projection_4layers_teste27.tif")
ensemble_raster <- rast(ensemble_path)

# Mapa final
suitability_map <- ggplot() +
  geom_spatraster(data = ensemble_raster) +
  geom_sf(data = countries, fill = NA, color = "black", linewidth = 0.2) +
  geom_point(data = pres_coords, aes(x = lon, y = lat), color = "red", size = 1, alpha = 0.6) +
  scale_fill_viridis_c(option = "plasma", name = "Adequabilidade", na.value = NA) +
  coord_sf(xlim = c(-120, -30), ylim = c(-60, 30)) +
  theme_minimal() +
  labs(title = "Mapa de Adequabilidade - Ensemble Final",
       subtitle = "Modelo combinando GLM, GAM, GBM, RF, MAXENT e Ensemble")

# Gr√°fico de import√¢ncia
importance_plot <- ggplot(importance_df, aes(x = reorder(var, importance), y = importance, fill = var)) +
  geom_col(alpha = 0.8) +
  geom_text(aes(label = paste0(var, "\n", round(importance, 3))), hjust = -0.1, size = 3.5) +
  coord_flip(ylim = c(0, max(importance_df$importance) * 1.2)) +
  scale_fill_viridis_d(option = "C") +
  theme_minimal() +
  labs(x = "", y = "Import√¢ncia", 
       title = "Import√¢ncia das Vari√°veis no Ensemble",
       subtitle = "Baseado no consenso entre todos os algoritmos") +
  theme(legend.position = "none")

# Layout final
final_plot <- (suitability_map | importance_plot) / diagnostic_plot / evaluation_plot +
  plot_annotation(title = "RELAT√ìRIO COMPLETO - MODELAGEM DE NICHO ECOL√ìGICO",
                  subtitle = "Vampyrum spectrum - Teste 27 (Incluindo Ensemble)")

ggsave(file.path(output_dir, "04_Resumo_Completo_teste27.png"), 
       final_plot, width = 16, height = 22, dpi = 300)

# ============================
# RELAT√ìRIO FINAL
# ============================

cat("\n", rep("=", 70), "\n")
cat("RELAT√ìRIO FINAL - MODELAGEM CONCLU√çDA (TESTE27)\n")
cat(rep("=", 70), "\n\n")

cat("‚úì Dados de ocorr√™ncia:", nrow(occ_data), "registros\n")
cat("‚úì Vari√°veis ambientais: 4 vari√°veis processadas\n")
cat("‚úì Modelos executados: GLM, GAM, GBM, RF, MAXENT + ENSEMBLE\n")
cat("‚úì Ensemble criado: EMmean, EMci\n")
cat("‚úì Proje√ß√µes geradas: Modelos individuais + Ensemble\n\n")

cat("IMPORT√ÇNCIA DAS VARI√ÅVEIS NO ENSEMBLE:\n")
for(i in 1:nrow(importance_df)) {
  cat(sprintf("  %d. %s: %.3f\n", i, importance_df$var[i], importance_df$importance[i]))
}

cat("\nDESEMPENHO DO ENSEMBLE:\n")
if (!is.na(ensemble_tss)) cat("  TSS do Ensemble:", round(ensemble_tss, 3), "\n")
if (!is.na(ensemble_roc)) cat("  ROC do Ensemble:", round(ensemble_roc, 3), "\n")

cat("\nARQUIVOS SALVOS EM:", output_dir, "\n")
cat("- Dados de ocorr√™ncia e ambientais processados\n")
cat("- Modelos e avalia√ß√µes (incluindo ensemble)\n")
cat("- Proje√ß√µes individuais e do ensemble\n")
cat("- Gr√°ficos de confiabilidade com ensemble\n")
cat("- Diagn√≥stico visual completo\n")
cat("- Relat√≥rios em CSV\n")

cat("\n", rep("=", 70), "\n")
cat("PROCESSO CONCLU√çDO COM SUCESSO! üéâ\n")
cat(rep("=", 70), "\n")
