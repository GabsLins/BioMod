
######## 4 LAYERS
## Occurrence data
occurence <- read.csv("C:/Users/tunho/Desktop/GAB/Mod/Tabela Ocorrência V. spectrum_DADOS BRUTOS EM PREPARAÇÃO - Modelagem_Dec_All.csv")
coords <- data.frame(x = occurence$longitude, y = occurence$latitude)
resp.var <- rep(1, 301)
sp <- SpatialPoints(coords, proj4string = CRS("EPSG:4326"))

occ_data <- data.frame(
  species = rep("Vampyrum_spectrum", 301), 
  lon = c(coords$x),
  lat = c(coords$y)
)


## Environmental data
library(raster)
vaporpressure <- raster("C:/Users/tunho/Desktop/GAB/Mod/meanvaporpressure.tif")
meantemperature <- raster("C:/Users/tunho/Desktop/GAB/Mod/media_anual_tavg_C.tif")
bioclimaticvar <- raster("C:/Users/tunho/Desktop/GAB/Mod/precipitacao_media_anual.tif")
relevo <- raster("C:/Users/tunho/Desktop/GAB/Mod/output_GMRT.tif")

# Definir a nova extensão com os novos limites
ext_america <- extent(-170, -26, -56, 72)

# Redimensionar e recortar
res <- 0.1  

vaporpressure <- resample(crop(vaporpressure, ext_america), bioclimaticvar, method='bilinear')
meantemperature <- resample(crop(meantemperature, ext_america), bioclimaticvar, method='bilinear')
bioclimaticvar <- resample(crop(bioclimaticvar, ext_america), bioclimaticvar, method='bilinear')
relevo <- resample(crop(relevo, ext_america), bioclimaticvar, method='bilinear')


env_data4layers <- stack(vaporpressure, meantemperature, bioclimaticvar, relevo)


## BioMod2 Formated Data Object
biomod_data4layers <- BIOMOD_FormatingData(
  resp.var = resp.var, 
  expl.var = env_data4layers, 
  resp.xy = coords,
  PA.nb.rep = 5,
  PA.nb.absences = 700,
  PA.strategy = "random",
  filter.raster = FALSE,
  resp.name = "Vampyrum.spectrum"
)


## BioMod2 Modeling
models_4layers <- BIOMOD_Modeling(
  biomod_data4layers,
  modeling.id = "current", 
  models = c('GLM', 'GAM', 'GBM', 'RF', 'MAXENT'), 
  CV.strategy = 'block',  #needs to be block, due to the spatial correlation
  prevalence = 0.5,       # Automatically set by the pseudo-absence generation
  var.import = 3,          # N of repetitions to calculate variable importance
  metric.eval = c('TSS', 'ROC'),
)


## Save Graphical outputs
gg1_4layers <- bm_PlotEvalMean(models_4layers, metric.eval = c("TSS", "ROC"), dataset = "calibration", do.plot = TRUE)
dev.new()
gg2_4layers <- bm_PlotEvalMean(models_4layers, metric.eval = c("TSS", "ROC"), dataset = "validation", do.plot = TRUE)


## Variables importance
var_importance4 <- get_variables_importance(models_4layers)
var_imp_df4 <- as.data.frame(var_importance4, stringsAsFactors = FALSE)
imp_expl4 <- data.frame(
  expl_var = var_imp_df4$expl.var,
  var_imp = as.numeric(var_imp_df4$var.imp),
  stringsAsFactors = FALSE
)
mean_imp_var_4layers <- aggregate(var_imp ~ expl_var, data = imp_expl4, FUN = mean)
arrange(mean_imp_var_4layers, desc(var_imp))


## BioMod2 Projections
projections_4layers <- BIOMOD_Projection(
  bm.mod = models_4layers,
  proj.name = "current",
  new.env = env_data4layers,
  models.chosen = "all"
) 


library(terra)
library(ggplot2)
library(tidyterra)

output_dir <- "C:/Users/tunho/Desktop/GAB/Mod/Resultados_Teste16_ensemble_teste15"
if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)

proj_stack <- get_predictions(projections_4layers)
proj_names <- names(proj_stack)

# Loop usando terra
for (i in 1:terra::nlyr(proj_stack)) {
  camada <- proj_stack[[i]]
  nome <- proj_names[i]
  
  out_tif <- file.path(output_dir, paste0(nome, ".tif"))
  out_png <- file.path(output_dir, paste0(nome, ".png"))
  
  # Salvar raster como GeoTIFF
  terra::writeRaster(camada, out_tif, overwrite = TRUE)

  # Salvar PNG em 4K
  p <- autoplot(camada) +
    ggtitle(paste("Projeção -", nome)) +
    theme_minimal(base_size = 22)
  
  ggsave(filename = out_png, plot = p, width = 3840, height = 2160, units = "px", dpi = 300)
}



## BioMod2 Ensemble
ensemble_4layers <- BIOMOD_EnsembleModeling(
  bm.mod = models_4layers,
  models.chosen = "all",
  em.by = "all",
  em.algo = c('EMmean', 'EMci'),
  metric.select = c('TSS','ROC'),
  metric.select.thresh = c(0.5, 0.7),
  var.import = 3,
  seed.val = 42
)

get_evaluations(ensemble_4layers)
bm_PlotEvalMean(bm.out = ensemble_4layers, metric.eval = c('TSS', 'ROC'), dataset = 'calibration', group.by = 'algo')
dev.new()
bm_PlotEvalBoxplot(bm.out = ensemble_4layers, group.by = c('algo', 'algo'))


## Variable Importance
EMvar_imp4 <- get_variables_importance(ensemble_4layers)
EMvar_imp_df4 <- as.data.frame(EMvar_imp4, stringsAsFactors = FALSE)
EMimp_expl4 <- data.frame(
  expl_var = EMvar_imp_df4$expl.var,
  var_imp = as.numeric(EMvar_imp_df4$var.imp),
  stringsAsFactors = FALSE
)
EMmean_imp_var4 <- arrange(aggregate(var_imp ~ expl_var, data = EMimp_expl4, FUN = mean), desc(var_imp))
EMmean_imp_var4


## Ensemble projection
myBiomodEnsembleProj <- BIOMOD_EnsembleForecasting(
  bm.em = ensemble_4layers,
  proj.name = "ensemble_4layers",
  models.chosen = "all",
  new.env = env_data4layers,
  binary.meth = NULL, # Pode definir um threshold binário se quiser
  compress = FALSE
)

ensemble_raster <- stack(file.path(getwd(), "Vampyrum.spectrum", "proj_proj4_current", "proj_proj4_current_Vampyrum.spectrum.tif"))
plot(ensemble_raster)

## COM GRADE!!!
### Aqui vai fazer o mapa com grade:

library(ggplot2)
library(tidyterra)
library(terra)
library(sf)
library(rnaturalearth)
library(ggspatial) # Para escala e norte
library(dplyr)

# Carregue o raster
ensemble_raster <- rast("C:/Users/tunho/Documents/Vampyrum.spectrum/proj_ensemble/proj_ensemble_Vampyrum.spectrum_ensemble.tif")

# Obter shapefile dos países
countries <- ne_countries(scale = "medium", returnclass = "sf")

# Definir a extensão da sua área de estudo (ajuste conforme necessário)
x_limits <- c(-120, -30)  # Longitude
y_limits <- c(-60, 30)    # Latitude

# Função para converter decimal para GMS
decimal_to_dms <- function(decimal, type = "lon") {
  degrees <- floor(abs(decimal))
  minutes <- floor((abs(decimal) - degrees) * 60)
  seconds <- round((((abs(decimal) - degrees) * 60) - minutes) * 60, 1)
  
  hemisphere <- ifelse(type == "lon", 
                       ifelse(decimal >= 0, "E", "W"),
                       ifelse(decimal >= 0, "N", "S"))
  
  paste0(degrees, "°", minutes, "'", seconds, "\"", hemisphere)
}

# Criar sequência de coordenadas para a grade
longitude_breaks <- seq(-120, -30, by = 15) ## se quiser mudar a distancia, tem que mudar o "by"
latitude_breaks <- seq(-60, 30, by = 15) ## se quiser mudar a distancia, tem que mudar o "by"

# Converter para formato GMS
longitude_labels <- sapply(longitude_breaks, decimal_to_dms, type = "lon")
latitude_labels <- sapply(latitude_breaks, decimal_to_dms, type = "lat")

# Mapa com grade GMS
ggplot() +
  geom_spatraster(data = ensemble_raster) +
  # Contorno dos países
  geom_sf(data = countries, fill = NA, color = "black", size = 0.5) +
  # Preenchimento do raster
  scale_fill_viridis_c(
    option = "plasma",
    na.value = NA,
    name = "Adequabilidade\nde Habitat"
  ) +
  # Grade de coordenadas em GMS
  scale_x_continuous(
    breaks = longitude_breaks,
    labels = longitude_labels,
    expand = c(0, 0)
  ) +
  scale_y_continuous(
    breaks = latitude_breaks,
    labels = latitude_labels,
    expand = c(0, 0)
  ) +
  # Sistema de coordenadas
  coord_sf(xlim = x_limits, ylim = y_limits) +
  # Elementos do tema e grade
  theme_minimal() +
  theme(
    panel.grid.major = element_line(color = "gray80", size = 0.2),
    panel.grid.minor = element_line(color = "gray90", size = 0.1),
    panel.background = element_rect(fill = "lightblue", colour = NA),
    legend.position = "right"
  ) +
  # Adicionar escala e rosa dos ventos
  annotation_scale(
    location = "bl",
    width_hint = 0.2,
    style = "ticks"
  ) +
  annotation_north_arrow(
    location = "tr",
    which_north = "true",
    style = north_arrow_fancy_orienteering
  ) +
  # Rótulos dos eixos
  labs(
    x = "Longitude",
    y = "Latitude",
    title = "Projeção do Modelo - Vampyrum spectrum",
    subtitle = "Modelagem de Nicho"
  )

# Salvar em alta qualidade
ggsave("mapa_grade_gms.png",
       width = 932, ##3840 para 4k
       height = 552, ##2160 para 4k
       dpi = 300,
       bg = "white") ### coloca transparent pra usar como png e colar em qualquer apresentacao
