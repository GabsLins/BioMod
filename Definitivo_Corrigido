# ======================================================
# Vampyrum spectrum – Models + Ensemble + FINAL Panel
# (CLEAN SCRIPT / teste77)
# ======================================================

# -----------------------------
# 0) Packages
# -----------------------------
library(biomod2)
library(sp)
library(raster)
library(terra)
library(dplyr)
library(ggplot2)
library(sf)
library(patchwork)
library(rnaturalearth)
library(rnaturalearthdata)
library(viridis)

set.seed(42)

# -----------------------------
# 1) Output directory (teste77)
# -----------------------------
output_dir <- "C:/Users/Administrador/Desktop/GAB/Mod/Resultados_teste77_ensemble"
dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
cat("Output:", output_dir, "\n")

# ======================================================
# 2) Occurrences
# ======================================================
occ_csv <- "C:/Users/Administrador/Desktop/GAB/Mod/Tabela Ocorrência V. spectrum_DADOS BRUTOS EM PREPARAÇÃO - Modelagem_Dec_All4.csv"
occ <- read.csv(occ_csv)

coords <- occ %>%
  dplyr::select(longitude, latitude) %>%
  dplyr::rename(x = longitude, y = latitude) %>%
  dplyr::filter(is.finite(x), is.finite(y))

resp.var <- rep(1, nrow(coords))
cat("Occurrences:", nrow(coords), "\n")

write.csv(
  data.frame(species="Vampyrum_spectrum", lon=coords$x, lat=coords$y),
  file.path(output_dir, "occurrences_teste77.csv"),
  row.names = FALSE
)

# ======================================================
# 3) Environmental layers (STANDARDIZATION)
# ======================================================
ext_america <- raster::extent(-170, -26, -56, 72)

prep_layer <- function(path, ref = NULL) {
  r <- raster::raster(path)
  r <- raster::crop(r, ext_america)
  if (!is.null(ref)) r <- raster::resample(r, ref, method = "bilinear")
  r
}

BIO7   <- prep_layer("C:/Users/Administrador/Desktop/Gab/Mod/wc2.1_2.5m_bio/wc2.1_2.5m_bio_7.tif")
vapor  <- prep_layer("C:/Users/Administrador/Desktop/GAB/Mod/meanvaporpressure.tif", BIO7)
wind   <- prep_layer("C:/Users/Administrador/Desktop/GAB/Mod/wind_media_anual.tif", BIO7)
relevo <- prep_layer("C:/Users/Administrador/Desktop/GAB/Mod/output_GMRT.tif", BIO7)

relevo[relevo < 0] <- NA

env <- raster::stack(vapor, wind, relevo, BIO7)
names(env) <- c("Vapor_Pressure","Wind","Elevation","Temperature_Variation")
cat("Layers:", paste(names(env), collapse = ", "), "\n")

# Checkpoints
raster::writeRaster(vapor,  file.path(output_dir, "Vapor_Pressure.tif"), overwrite = TRUE)
raster::writeRaster(wind,   file.path(output_dir, "Wind.tif"), overwrite = TRUE)
raster::writeRaster(relevo, file.path(output_dir, "Elevation.tif"), overwrite = TRUE)
raster::writeRaster(BIO7,   file.path(output_dir, "BIO7.tif"), overwrite = TRUE)

# ======================================================
# 4) MASK + apply to env (biomod2 old-compatible)
#     - keep all islands
#     - neutralize only Antilles (2 boxes)
#     - exclude custom polygon/quadrant (4 vertices)
# ======================================================
mask_path <- "C:/Users/Administrador/Desktop/Gab/Mod/mask_america_extent.tif"

stopifnot(inherits(env, c("RasterStack","RasterBrick")))

mask_r <- raster::raster(mask_path)
ref_r  <- env[[1]]

# (A) CRS align
if (!raster::compareCRS(mask_r, ref_r)) {
  message("Reprojecting mask to env CRS...")
  mask_r <- raster::projectRaster(mask_r, ref_r, method = "ngb")
}

# (B) Grid align
mask_r <- raster::resample(mask_r, ref_r, method = "ngb")
mask_r <- raster::crop(mask_r, raster::extent(ref_r))

# (C) Normalize mask to {1, NA}
mask_r[mask_r <= 0] <- NA
mask_r[mask_r >  0] <- 1


# ---------- (E) Exclude your custom polygon/quadrant (4 vertices) ----------
# Given as (lat, lon) -> use (x=lon, y=lat)
poly_df <- data.frame(
  x = c(-85.469, -84.658, -59.768, -65.544),
  y = c( 24.029,  17.675,  12.883,  23.414)
)

sp_poly <- sp::SpatialPolygons(
  list(sp::Polygons(list(sp::Polygon(as.matrix(poly_df))), ID="excl_poly")),
  proj4string = sp::CRS("+proj=longlat +datum=WGS84 +no_defs")
)

if (!raster::compareCRS(mask_r, sp_poly)) {
  sp_poly <- sp::spTransform(sp_poly, raster::crs(mask_r))
}

burn_poly <- raster::rasterize(sp_poly, mask_r, field = 1, background = NA)
mask_r[!is.na(burn_poly)] <- NA

# Save final mask used in modeling
raster::writeRaster(mask_r, file.path(output_dir, "mask_used_noAntilles_plusPolygon_teste77.tif"),
                    overwrite = TRUE)

# (F) Apply mask to predictors
env_masked <- raster::stack(lapply(1:raster::nlayers(env), function(i) {
  raster::mask(env[[i]], mask_r)
}))
names(env_masked) <- names(env)

stopifnot(inherits(env_masked, "RasterStack"))

# ======================================================
# 5) BIOMOD_FormatingData (with PA)
# biomod2 old: filter.raster must be logical => TRUE
# (mask already applied in env_masked)
# ======================================================
biomod_data <- BIOMOD_FormatingData(
  resp.var = resp.var,
  expl.var = env_masked,
  resp.xy  = coords,
  PA.nb.rep = 10,
  PA.nb.absences = 600,
  PA.strategy = "random",
  PA.dist.min = 20000,
  PA.dist.max = 150000,
  filter.raster = TRUE,
  resp.name = "Vampyrum.spectrum"
)

saveRDS(biomod_data, file.path(output_dir, "biomod_data_teste77.rds"))
cat("✔ BIOMOD_FormatingData done (env masked; Antilles + polygon excluded).\n")

# ======================================================
# 6) Modeling
# ======================================================
myOptions <- BIOMOD_ModelingOptions(
  GBM = list(n.trees = 2000, interaction.depth = 2, shrinkage = 0.005,
             bag.fraction = 0.5, n.minobsinnode = 10),
  GLM = list(type = "simple", test = "BIC"),
  GAM = list(k = 3)
)

models <- BIOMOD_Modeling(
  biomod_data,
  models = c("GLM","GAM","GBM"),
  bm.options = myOptions,
  CV.strategy = "block",
  CV.nb.rep = 5,
  prevalence = 0.5,
  metric.eval = c("TSS","ROC"),
  var.import = 3
)

saveRDS(models, file.path(output_dir, "models_teste77.rds"))

# ======================================================
# 7) Ensemble
# ======================================================
ensemble <- BIOMOD_EnsembleModeling(
  bm.mod = models,
  models.chosen = "all",
  em.by = "all",
  em.algo = c("EMmean"),
  metric.select = c("TSS","ROC"),
  metric.select.thresh = c(0.5, 0.7),
  var.import = 3
)

saveRDS(ensemble, file.path(output_dir, "ensemble_teste77.rds"))

# ======================================================
# 7B) APPLY MASK TO ENSEMBLE + NEUTRALIZE ONLY LAND IN ANTILLES POLYGON
#     (Ocean stays NA; islands stay present)
# ======================================================

mask_path <- "C:/Users/Administrador/Desktop/Gab/Mod/mask_america_extent.tif"

# --- (0) Read mask fresh (avoid invalid pointers) ---
m0 <- terra::rast(mask_path)

# --- (1) Align CRS to ensemble ---
if (!terra::same.crs(m0, ensemble_raster_single)) {
  message("Reprojecting mask to ensemble CRS...")
  m0 <- terra::project(m0, ensemble_raster_single, method = "near")
}

# --- (2) Align grid to ensemble ---
m0 <- terra::resample(m0, ensemble_raster_single, method = "near")

# --- (3) Normalize mask: keep >0 (1), remove <=0 (NA) ---
m0 <- terra::ifel(m0 > 0, 1, NA)

# ------------------------------------------------------
# (4) Build a LAND mask (so ocean becomes NA)
#     Uses rnaturalearth polygons and rasterizes on the SAME grid
# ------------------------------------------------------
countries_sf <- rnaturalearth::ne_countries(scale = "medium", returnclass = "sf")
countries_v  <- terra::vect(countries_sf)

land <- terra::rasterize(countries_v, m0, field = 1, background = NA)
# land: 1 on land, NA on ocean

# Combine: accessible area AND land
m <- terra::ifel(!is.na(land) & !is.na(m0), 1, NA)

# ------------------------------------------------------
# (5) Apply combined mask to ensemble (ocean already NA)
# ------------------------------------------------------
ens_masked <- terra::mask(ensemble_raster_single, m)

if (!terra::hasValues(ens_masked)) {
  stop("Masked ensemble has no values. Check mask_america_extent.tif overlap/CRS.")
}

# ------------------------------------------------------
# (6) Neutralize ONLY LAND inside your Antilles polygon
#     Points given as (lat, lon) -> here we build polygon in lon/lat
#     and then project to raster CRS if needed
# ------------------------------------------------------

# Your 4 vertices (lat, lon):
# 24.029, -85.469
# 17.675, -84.658
# 12.883, -59.768
# 23.414, -65.544
# -> convert to (lon, lat) matrix
ant_ll <- rbind(
  c(-85.469, 24.029),
  c(-84.658, 17.675),
  c(-59.768, 12.883),
  c(-65.544, 23.414),
  c(-85.469, 24.029)  # close polygon
)

ant_poly <- terra::vect(list(ant_ll), type = "polygons", crs = "EPSG:4326")

# Project polygon to ensemble CRS if needed
if (!terra::same.crs(ant_poly, ens_masked)) {
  ant_poly <- terra::project(ant_poly, ens_masked)
}

# Rasterize polygon on SAME grid of ens_masked
burn_ant <- terra::rasterize(ant_poly, ens_masked, field = 1, background = NA)

# Identify cells to neutralize: (inside polygon) AND (land cells)
# land is on mask grid m0; ensure land grid matches ens_masked
land2 <- terra::resample(land, ens_masked, method = "near")
idx_neutralize <- (!is.na(burn_ant) & !is.na(land2))

# Neutralize on continuous map: set to 0 (extreme "nulo"), not NA
ens_masked[idx_neutralize] <- 0

# Update object used by plots
ensemble_raster_single <- ens_masked

# Save masked continuous ensemble
terra::writeRaster(
  ensemble_raster_single,
  filename = file.path(output_dir, "ensemble_suitability_MASKED_land_noAntilles.tif"),
  overwrite = TRUE
)

message("✔ Mask applied (land-only) + Antilles polygon neutralized on LAND only. Ocean remains NA; islands preserved.")


# ======================================================
# 8) Ensemble Forecasting (robust raster extraction)
# IMPORTANT: use env_masked here so the projection is already restricted
# ======================================================
ensemble_proj <- BIOMOD_EnsembleForecasting(
  bm.em = ensemble,
  proj.name = "current_teste77",
  new.env = env_masked
)
saveRDS(ensemble_proj, file.path(output_dir, "ensemble_proj_teste77.rds"))

pred_obj <- get_predictions(ensemble_proj)

# Try terra directly
ensemble_raster_single <- tryCatch(terra::rast(pred_obj)[[1]], error = function(e) NULL)

# Fallback via raster::stack
if (is.null(ensemble_raster_single) || !terra::hasValues(ensemble_raster_single)) {
  rs <- tryCatch(raster::stack(pred_obj), error = function(e) NULL)
  if (!is.null(rs)) ensemble_raster_single <- terra::rast(rs)[[1]]
}

if (is.null(ensemble_raster_single) || !terra::hasValues(ensemble_raster_single)) {
  stop("Could not obtain ensemble raster with values from BIOMOD_EnsembleForecasting.")
}

terra::writeRaster(
  ensemble_raster_single,
  file.path(output_dir, "ensemble_suitability_MASKED_noAntilles_plusPolygon_teste77.tif"),
  overwrite = TRUE
)

# ======================================================
# 7B) APPLY MASK TO ENSEMBLE + "NEUTRALIZAR" QUADRANTE (SEM REMOVER ILHAS)
#     - Mantém ilhas e continente visíveis
#     - Dentro do quadrante: Suitability = 0 (contínuo) e Binário = 0
#     - Opcional: também exclui quadrante da máscara de modelagem (NA)
# ======================================================

mask_path <- "C:/Users/Administrador/Desktop/Gab/Mod/mask_america_extent.tif"

# --- (1) Lê máscara base (fresh) e alinha ao ensemble ---
m_base <- terra::rast(mask_path)

if (!terra::same.crs(m_base, ensemble_raster_single)) {
  message("Reprojecting mask to ensemble CRS...")
  m_base <- terra::project(m_base, ensemble_raster_single, method = "near")
}
m_base <- terra::resample(m_base, ensemble_raster_single, method = "near")

# Normaliza: >0 fica 1, <=0 vira NA (fora da área)
m_base <- terra::ifel(m_base > 0, 1, NA)

# --- (2) Cria o polígono do quadrante (lon,lat) e projeta para CRS do raster ---
# Seus pontos (LAT, LON) -> aqui vamos montar como (LON, LAT)
quad_ll <- rbind(
  c(-85.469, 24.029),
  c(-84.658, 17.675),
  c(-59.768, 12.883),
  c(-65.544, 23.414),
  c(-85.469, 24.029)  # fecha polígono
)

quad_poly_ll <- terra::vect(quad_ll, type = "polygons", crs = "EPSG:4326")

# Projeta o polígono pro CRS do ensemble/máscara (se necessário)
quad_poly <- terra::project(quad_poly_ll, m_base)

# --- (3) Rasteriza o polígono NA MESMA grade do ensemble ---
burn_quad <- terra::rasterize(quad_poly, m_base, field = 1, background = NA)

# --- (4) (A) Máscara de MODELAGEM: exclui quadrante (vira NA) ---
# Use m_model no lugar de m_base se quiser que BIOMOD/PA não usem essa área
m_model <- m_base
m_model <- terra::ifel(!is.na(burn_quad), NA, m_model)

# (opcional) salvar a máscara de modelagem
terra::writeRaster(
  m_model,
  filename = file.path(output_dir, "mask_america_minus_quadrant_MODEL.tif"),
  overwrite = TRUE
)

# --- (5) (B) Mapa CONTÍNUO para VISUALIZAÇÃO:
# aplica máscara base, mas no quadrante coloca 0 (não some do mapa)
ens_cont_masked <- terra::mask(ensemble_raster_single, m_base)

# Aqui está o ponto-chave: quadrante NÃO vira NA, vira 0
ens_cont_masked <- terra::ifel(!is.na(burn_quad), 0, ens_cont_masked)

# Atualiza o raster que você usa nos plots
ensemble_raster_single <- ens_cont_masked

# Salva contínuo (com quadrante em 0, visível)
terra::writeRaster(
  ensemble_raster_single,
  filename = file.path(output_dir, "ensemble_suitability_MASKED_quadrantZERO_teste74.tif"),
  overwrite = TRUE
)

message("✔ 7B ok: máscara base aplicada; quadrante neutralizado (0) sem remover ilhas.")

# --- (6) Binários (TSS/ROC): quadrante automaticamente fica 0 ---
# Importante: aqui o threshold funciona normal e o quadrante (0) nunca vira 1.
if (exists("cut_tss") && is.finite(cut_tss)) {
  ens_bin_tss <- terra::ifel(is.na(ensemble_raster_single), NA,
                            terra::ifel(ensemble_raster_single >= cut_tss, 1, 0))
  terra::writeRaster(
    ens_bin_tss,
    filename = file.path(output_dir, "ensemble_binary_TSS_MASKED_quadrantZERO_teste74.tif"),
    overwrite = TRUE
  )
}

if (exists("cut_roc") && is.finite(cut_roc)) {
  ens_bin_roc <- terra::ifel(is.na(ensemble_raster_single), NA,
                            terra::ifel(ensemble_raster_single >= cut_roc, 1, 0))
  terra::writeRaster(
    ens_bin_roc,
    filename = file.path(output_dir, "ensemble_binary_ROC_MASKED_quadrantZERO_teste74.tif"),
    overwrite = TRUE
  )
}


# ======================================================
# 9) Binary ensemble maps (masked) using cutoffs
# ======================================================
ev_ens <- get_evaluations(ensemble)

get_ens_cutoff <- function(ev, by_metric = c("TSS","ROC")) {
  by_metric <- match.arg(by_metric)
  df <- ev %>% dplyr::filter(algo == "EMmean", metric.eval == by_metric)
  if ("filtered.by" %in% names(df)) {
    df2 <- df %>% dplyr::filter(filtered.by == by_metric)
    if (nrow(df2) > 0) df <- df2
  }
  if (!("cutoff" %in% names(df)) || nrow(df) == 0) return(NA_real_)
  as.numeric(df$cutoff[1])
}

cut_tss <- get_ens_cutoff(ev_ens, "TSS")
cut_roc <- get_ens_cutoff(ev_ens, "ROC")
cat("Ensemble cutoff (TSS):", cut_tss, "\n")
cat("Ensemble cutoff (ROC):", cut_roc, "\n")

save_binary_map <- function(ens_cont, cutoff_value, suffix) {
  if (!is.finite(cutoff_value)) {
    warning("Cutoff NA/invalid for ", suffix, ". Skipping.")
    return(invisible(NULL))
  }

  r_bin <- ens_cont >= cutoff_value
  r_bin <- terra::ifel(is.na(ens_cont), NA, r_bin)
  r_bin <- terra::ifel(r_bin, 1, 0)

  terra::writeRaster(
    r_bin,
    file.path(output_dir, paste0("ensemble_binary_", suffix, "_MASKED_teste77.tif")),
    overwrite = TRUE
  )

  df_bin <- as.data.frame(r_bin, xy = TRUE, na.rm = TRUE)
  colnames(df_bin)[3] <- "Binary"

  p_bin <- ggplot() +
    geom_raster(data = df_bin, aes(x = x, y = y, fill = factor(Binary))) +
    scale_fill_viridis_d(option = "C", name = paste0("Binary (", suffix, ")")) +
    coord_sf(expand = FALSE) +
    theme_minimal() +
    labs(title = paste0("Binary Ensemble (Masked) – ", suffix, " cutoff")) +
    theme(plot.title = element_text(face="bold", hjust=0.5))

  ggsave(
    file.path(output_dir, paste0("ensemble_binary_", suffix, "_MASKED_teste77.png")),
    plot = p_bin, width = 10, height = 7, units = "in", dpi = 300
  )

  invisible(r_bin)
}

bin_tss <- save_binary_map(ensemble_raster_single, cut_tss, "TSS")
bin_roc <- save_binary_map(ensemble_raster_single, cut_roc, "ROC")

# ======================================================
# 10) Evaluations (Models: validation | Ensemble: calibration)
# ======================================================
ev_models <- get_evaluations(models)
df_models <- ev_models %>%
  dplyr::filter(metric.eval %in% c("TSS","ROC")) %>%
  dplyr::transmute(Model = algo, Metric = metric.eval, Value = validation) %>%
  dplyr::filter(is.finite(Value), !is.na(Value))

df_ens <- ev_ens %>%
  dplyr::filter(algo == "EMmean", metric.eval %in% c("TSS","ROC")) %>%
  dplyr::transmute(Metric = metric.eval, Value = calibration) %>%
  dplyr::filter(is.finite(Value), !is.na(Value))

ens_tss <- df_ens %>% filter(Metric=="TSS") %>% pull(Value)
ens_roc <- df_ens %>% filter(Metric=="ROC") %>% pull(Value)
ens_tss <- ifelse(length(ens_tss)>0, ens_tss[1], NA_real_)
ens_roc <- ifelse(length(ens_roc)>0, ens_roc[1], NA_real_)

# ======================================================
# 11) Variable importance (with values)
# ======================================================
importance <- as.data.frame(get_variables_importance(ensemble)) %>%
  group_by(expl.var) %>%
  summarise(importance = mean(var.imp, na.rm = TRUE), .groups="drop") %>%
  rename(var = expl.var)

write.csv(importance, file.path(output_dir, "importance_teste77.csv"), row.names = FALSE)

importance_plot <- ggplot(
  importance %>% arrange(desc(importance)),
  aes(x = reorder(var, importance), y = importance)
) +
  geom_col(fill = "steelblue") +
  geom_text(aes(label = sprintf("%.3f", importance)),
            hjust = -0.15, size = 3.5) +
  coord_flip() +
  scale_y_continuous(expand = expansion(mult = c(0, 0.15))) +
  theme_minimal() +
  labs(title="Variable Importance (Ensemble)", x="", y="Importance") +
  theme(plot.title = element_text(face="bold", hjust=0.5))

# ======================================================
# 12) Pseudo-absences (robust via @PA.table)
# ======================================================
rep_id <- 1
pa_colname <- paste0("PA", rep_id)

if (!("PA.table" %in% slotNames(biomod_data))) stop("biomod_data has no PA.table.")
pa_tab <- biomod_data@PA.table
if (is.null(pa_tab) || nrow(pa_tab) == 0) stop("PA.table is empty.")

if (!is.null(colnames(pa_tab)) && (pa_colname %in% colnames(pa_tab))) {
  pa_vec <- pa_tab[, pa_colname]
} else {
  pa_vec <- pa_tab[, 1]
  warning("Column ", pa_colname, " not found. Using first PA.table column.")
}

abs_idx <- which(is.finite(pa_vec) & pa_vec == 0)
if (length(abs_idx) == 0) stop("No pseudo-absences (0) found in PA.table.")

pa_pts <- biomod_data@coord[abs_idx, , drop = FALSE]
pa_pts <- as.data.frame(pa_pts)
colnames(pa_pts) <- c("x","y")
cat("Pseudo-absences (rep", rep_id, "):", nrow(pa_pts), "\n")

# ======================================================
# 13) Predictor panels (no geom_spatraster)
# ======================================================
as_xy_df <- function(obj) {
  df <- as.data.frame(obj)
  if (all(c("x","y") %in% names(df))) return(df[, c("x","y"), drop=FALSE])
  if (all(c("lon","lat") %in% names(df))) { out <- df[, c("lon","lat"), drop=FALSE]; names(out) <- c("x","y"); return(out) }
  if (all(c("longitude","latitude") %in% names(df))) { out <- df[, c("longitude","latitude"), drop=FALSE]; names(out) <- c("x","y"); return(out) }
  num_cols <- which(sapply(df, is.numeric))
  if (length(num_cols) >= 2) {
    out <- df[, num_cols[1:2], drop=FALSE]
    names(out) <- c("x","y")
    warning("Coordinates without standard names; used first 2 numeric columns as x,y.")
    return(out)
  }
  stop("Could not extract x,y coordinates.")
}

as_points_vect <- function(xy_df, crs_str) {
  xy_df <- as.data.frame(xy_df)
  terra::vect(xy_df, geom = c("x","y"), crs = crs_str)
}

make_var_panel <- function(r, varname, coords_obj, pa_obj, imp_df) {

  rr <- terra::rast(r)
  crs_r <- terra::crs(rr)
  if (is.na(crs_r) || crs_r == "") crs_r <- "EPSG:4326"

  coords_xy <- as_xy_df(coords_obj)
  pa_xy     <- as_xy_df(pa_obj)

  coords_v  <- as_points_vect(coords_xy, crs_r)
  pa_v      <- as_points_vect(pa_xy, crs_r)

  imp_val <- imp_df %>% dplyr::filter(var == varname) %>% dplyr::pull(importance)
  imp_txt <- ifelse(length(imp_val)>0, sprintf(" | Imp: %.3f", imp_val[1]), " | Imp: NA")

  rr_crop <- tryCatch(terra::crop(rr, terra::ext(-120, -30, -60, 30)), error=function(e) NULL)
  rr_use <- rr_crop
  if (is.null(rr_use) || !terra::hasValues(rr_use)) rr_use <- rr

  r_df <- as.data.frame(rr_use, xy=TRUE, na.rm=TRUE)
  colnames(r_df)[3] <- "val"

  map <- ggplot() +
    geom_raster(data = r_df, aes(x=x, y=y, fill=val)) +
    geom_point(data = coords_xy, aes(x = x, y = y),
               color = "red", size = 0.6, alpha = 0.7) +
    scale_fill_viridis_c(option="viridis", name=varname) +
    coord_sf(expand = FALSE) +
    theme_minimal() +
    labs(title = paste0(varname, imp_txt))

  pres_vals <- terra::extract(rr, coords_v)[,2]
  pa_vals   <- terra::extract(rr, pa_v)[,2]

  df <- data.frame(
    Value = c(pres_vals, pa_vals),
    Group = c(rep("Presence", length(pres_vals)),
              rep("Pseudo-absence", length(pa_vals)))
  ) %>% dplyr::filter(is.finite(Value), !is.na(Value))

  dist <- ggplot(df, aes(Group, Value, fill=Group)) +
    geom_violin(alpha=0.35, trim=TRUE, color=NA) +
    geom_boxplot(width=0.25, outlier.size=1) +
    theme_minimal() +
    labs(title=paste("Distribution –", varname), x="", y="") +
    theme(legend.position="none")

  map | dist
}

var_panels <- lapply(names(env_masked), function(v) make_var_panel(env_masked[[v]], v, coords, pa_pts, importance))
names(var_panels) <- names(env_masked)

vars_panel <- wrap_plots(var_panels, ncol=2) +
  plot_annotation(
    title="Environmental Predictors: Map + Distribution (Presence × Pseudo-absence)",
    theme = theme(plot.title = element_text(face="bold", hjust=0.5))
  )

# ======================================================
# 14) Final maps + metrics plots + FINAL PANEL
# ======================================================
countries <- rnaturalearth::ne_countries(scale="medium", returnclass="sf")
pres_coords <- data.frame(lon = coords$x, lat = coords$y)

target_ext <- terra::ext(-120, -30, -60, 30)
ens_crop <- tryCatch(terra::crop(ensemble_raster_single, target_ext), error=function(e) NULL)
use_r <- ens_crop
if (is.null(use_r) || !terra::hasValues(use_r)) use_r <- ensemble_raster_single

ens_df <- as.data.frame(use_r, xy=TRUE, na.rm=TRUE)
colnames(ens_df)[3] <- "Suitability"

if (!is.null(ens_crop) && terra::hasValues(ens_crop)) {
  xlim_use <- c(-120, -30); ylim_use <- c(-60, 30)
} else {
  e <- terra::ext(use_r)
  xlim_use <- c(e$xmin, e$xmax); ylim_use <- c(e$ymin, e$ymax)
}

suitability_map <- ggplot() +
  geom_raster(data = ens_df, aes(x=x, y=y, fill=Suitability)) +
  geom_sf(data = countries, fill=NA, color="black", linewidth=0.2) +
  geom_point(data = pres_coords, aes(x=lon, y=lat), color="red", size=1, alpha=0.6) +
  scale_fill_viridis_c(option="plasma", name="Suitability") +
  coord_sf(xlim=xlim_use, ylim=ylim_use, expand=FALSE) +
  theme_minimal() +
  labs(title="Habitat Suitability Map – Ensemble (Masked)") +
  theme(plot.title = element_text(face="bold", hjust=0.5))

plot_metric <- function(metric, lim, ens_val) {
  p <- ggplot(df_models %>% filter(Metric==metric),
              aes(Model, Value, fill=Model)) +
    geom_violin(alpha=0.4, trim=TRUE, color=NA) +
    geom_boxplot(width=0.3, outlier.size=1) +
    geom_hline(yintercept=lim, linetype="dashed", color="red") +
    theme_minimal() +
    coord_cartesian(ylim=c(0,1)) +
    theme(legend.position="none") +
    labs(title=metric, x="Model", y=metric)

  if (is.finite(ens_val)) {
    p <- p +
      geom_hline(yintercept=ens_val, color="blue", linewidth=1.1) +
      annotate("text", x=Inf, y=ens_val,
               label = sprintf("Ensemble = %.3f", ens_val),
               hjust=1.05, vjust=-0.4, color="blue", size=3.5)
  }
  p
}

tss_plot <- plot_metric("TSS", 0.7, ens_tss)
roc_plot <- plot_metric("ROC", 0.8, ens_roc)
evaluation_panel <- tss_plot | roc_plot

final_panel <- (suitability_map | importance_plot) /
  vars_panel /
  evaluation_panel +
  plot_annotation(
    title="FULL PANEL – Ecological Niche Modeling",
    theme = theme(plot.title = element_text(size=14, face="bold", hjust=0.5))
  )

out_panel <- file.path(output_dir, "04_FINAL_PANEL_teste77.png")
cat("Saving:", out_panel, "\n")

ok <- tryCatch({
  ggsave(out_panel, plot = final_panel, width=22, height=24, units="in", dpi=300, limitsize=FALSE)
  TRUE
}, error=function(e) FALSE)

if (!ok) {
  png(out_panel, width=22, height=24, units="in", res=300)
  print(final_panel)
  dev.off()
}

cat("✅ Done. Files in:", output_dir, "\n")

# ======================================================
# 15) SAVE PANEL PARTS (PNG + TIF)
# ======================================================
parts_dir <- file.path(output_dir, "panel_parts")
dir.create(parts_dir, recursive = TRUE, showWarnings = FALSE)

save_plot_png_tif <- function(p, filename_base, w = 12, h = 8, dpi = 300) {
  ggsave(file.path(parts_dir, paste0(filename_base, ".png")),
         plot = p, width = w, height = h, units = "in",
         dpi = dpi, limitsize = FALSE)

  ggsave(file.path(parts_dir, paste0(filename_base, ".tif")),
         plot = p, width = w, height = h, units = "in",
         dpi = dpi, limitsize = FALSE,
         device = "tiff", compression = "lzw")
}

save_plot_png_tif(final_panel,      "00_final_panel",        w = 22, h = 24)
save_plot_png_tif(suitability_map,  "01_ensemble_map",       w = 12, h = 8)
save_plot_png_tif(importance_plot,  "02_variable_importance",w = 10, h = 6)
save_plot_png_tif(vars_panel,       "03_predictor_panels",   w = 18, h = 12)
save_plot_png_tif(tss_plot,         "04_TSS_models",         w = 10, h = 6)
save_plot_png_tif(roc_plot,         "05_ROC_models",         w = 10, h = 6)
save_plot_png_tif(evaluation_panel, "06_metrics_panel",      w = 16, h = 6)

if (exists("var_panels") && length(var_panels) > 0) {
  for (nm in names(var_panels)) {
    safe_nm <- gsub("[^A-Za-z0-9_\\-]+", "_", nm)
    save_plot_png_tif(var_panels[[nm]], paste0("07_predictor_", safe_nm), w = 12, h = 6)
  }
}

cat("✅ Saved all panel parts to:", parts_dir, "\n")
