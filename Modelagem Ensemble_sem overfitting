# ======================================================
# MODELAGEM COM BUFFER (M) NA CALIBRAÇÃO + PROJEÇÃO NO MAPA GRANDE
# Vampyrum spectrum | BIOMOD2
# ======================================================
# Autor: Gabriel Lins (adaptado)
# Data: 18-12-25
# ======================================================

# --- 0) Pacotes ---
suppressPackageStartupMessages({
  library(biomod2)
  library(sp)
  library(raster)
  library(terra)
  library(dplyr)
  library(ggplot2)
  library(tidyterra)
  library(sf)
  library(patchwork)
  library(rnaturalearth)
  library(rnaturalearthdata)
  library(viridis)
  library(tibble)
  library(utils)
})

# --- 1) Configurações e diretórios ---
output_dir <- "C:/Users/Administrador/Desktop/GAB/Mod/Resultados_teste56"
if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)
set.seed(42)

cat("Output dir:", output_dir, "\n")

# >>>>>>>>>>>> AJUSTE AQUI: BUFFER EM KM (2 ou 5) <<<<<<<<<<<<
buffer_km <- 50  # recomendado com pixel ~5 km; teste 2 km se quiser

# Helpers
safe_saveRDS <- function(obj, path) {
  tryCatch({
    saveRDS(obj, path)
    cat("✔ Saved:", path, "\n")
  }, error = function(e) {
    warning("Falha ao salvar ", path, ": ", e$message)
  })
}

run_safe <- function(expr, checkpoint_file = NULL) {
  tryCatch({
    res <- eval(expr)
    if (!is.null(checkpoint_file) && !is.logical(checkpoint_file)) safe_saveRDS(res, checkpoint_file)
    return(res)
  }, error = function(e) {
    msg <- paste0("ERRO em etapa: ", conditionMessage(e))
    cat(msg, "\n")
    writeLines(msg, file.path(output_dir, "error_log.txt"), sep = "\n", useBytes = TRUE)
    stop(e)
  })
}

# ======================================================
# 2) Dados de ocorrência
# ======================================================
cat("Carregando ocorrências...\n")
occ_csv <- "C:/Users/Administrador/Desktop/GAB/Mod/Tabela Ocorrência V. spectrum_DADOS BRUTOS EM PREPARAÇÃO - Modelagem_Dec_All3.csv"
occurence <- read.csv(occ_csv)

coords <- data.frame(x = occurence$longitude, y = occurence$latitude)
coords <- coords[complete.cases(coords), , drop = FALSE]

resp.var <- rep(1, nrow(coords))
sp_pts <- SpatialPoints(coords, proj4string = CRS("+proj=longlat +datum=WGS84"))

occ_data <- data.frame(species = rep("Vampyrum_spectrum", nrow(coords)), lon = coords$x, lat = coords$y)
write.csv(occ_data, file.path(output_dir, paste0("dados_ocorrencia_buffer_", buffer_km, "km.csv")), row.names = FALSE)
cat("✓ Ocorrências salvas. N:", nrow(occ_data), "\n")

# ======================================================
# 3) Camadas ambientais (4 variáveis) no MAPA GRANDE
# ======================================================
cat("Carregando camadas ambientais...\n")
vaporpressure <- raster("C:/Users/Administrador/Desktop/GAB/Mod/meanvaporpressure.tif")
wind          <- raster("C:/Users/Administrador/Desktop/GAB/Mod/wind_media_anual.tif")
relevo        <- raster("C:/Users/Administrador/Desktop/GAB/Mod/output_GMRT.tif")
BIO7          <- raster("C:/Users/Administrador/Desktop/Gab/Mod/wc2.1_2.5m_bio/wc2.1_2.5m_bio_7.tif")

# EXTENSÃO GRANDE (mantida)
ext_america <- extent(-170, -26, -56, 72)

# Resample / crop to BIO7 reference
vaporpressure <- resample(crop(vaporpressure, ext_america), BIO7, method = "bilinear")
wind          <- resample(crop(wind, ext_america), BIO7, method = "bilinear")
relevo        <- resample(crop(relevo, ext_america), BIO7, method = "bilinear")
BIO7          <- resample(crop(BIO7, ext_america), BIO7, method = "bilinear")

# remover relevo marinho
relevo[relevo < 0] <- NA

env_data4layers <- stack(vaporpressure, wind, relevo, BIO7)
names(env_data4layers) <- c("Pressao_Vapor", "Vento", "Relevo", "Variacao_de_Temperatura")
cat("Camadas carregadas:", paste(names(env_data4layers), collapse = ", "), "\n")

# salvar camadas processadas (checkpoints)
writeRaster(vaporpressure, file.path(output_dir, "vaporpressure_processado.tif"), overwrite = TRUE)
writeRaster(wind,          file.path(output_dir, "wind_processado.tif"), overwrite = TRUE)
writeRaster(relevo,        file.path(output_dir, "relevo_processado.tif"), overwrite = TRUE)
writeRaster(BIO7,          file.path(output_dir, "BIO7_processado.tif"), overwrite = TRUE)

# ======================================================
# 4) Criar M por buffer (km) e gerar env_calib (RasterStack)
# ======================================================
buffer_km <- 50  # mude aqui: 2 ou 5

cat("Criando máscara M (buffer) de ", buffer_km, " km...\n", sep="")

# Garanta que estamos usando o raster "raster", não terra
r0 <- env_data4layers[[1]]  # RasterLayer

# Distância (km) da célula ao ponto mais próximo
d_km <- raster::distanceFromPoints(r0, coords) / 1000  # RasterLayer

# Máscara M (1 dentro do buffer, NA fora) - forma robusta
M_mask <- raster::calc(d_km, fun = function(x) ifelse(x <= buffer_km, 1, NA))
M_mask <- raster::mask(M_mask, r0)  # garante alinhamento e NA iguais ao raster base

# Aplicar máscara nas variáveis ambientais para calibração
env_calib <- raster::mask(env_data4layers, M_mask)

# FORÇAR tipo para evitar incompatibilidade
env_calib <- raster::stack(env_calib)

# Checagens essenciais (evita rodar com tudo NA)
cells_in_M <- sum(!is.na(raster::values(M_mask)))
cat("Células dentro do buffer:", cells_in_M, "\n")

# Se o buffer for pequeno demais (muito provável com 2 km e pixel ~5 km)
if (cells_in_M < 50) {
  stop("Buffer muito pequeno para o raster atual (", cells_in_M,
       " células). Tente buffer_km=5 (mínimo) ou maior.")
}

# Verifica se alguma camada ficou toda NA
na_layers <- sapply(1:raster::nlayers(env_calib), function(i) {
  all(is.na(raster::values(env_calib[[i]])))
})
if (any(na_layers)) {
  stop("Alguma camada em env_calib ficou 100% NA após aplicar o buffer. ",
       "Isso quebra a formatação. Aumente buffer_km ou revise as camadas.")
}

# Salvar máscara (opcional)
raster::writeRaster(M_mask,
                    filename = file.path(output_dir, paste0("M_mask_buffer_", buffer_km, "km.tif")),
                    overwrite = TRUE)

# ======================================================
# 5) Formatação BIOMOD2 (calibração dentro do buffer)
# ======================================================
cat("Formatando dados BIOMOD2 (calibração dentro do buffer)...\n")
bmdata_path <- file.path(output_dir, paste0("biomod_data_buffer_", buffer_km, "km.rds"))

if (file.exists(bmdata_path)) {
  biomod_data4layers <- readRDS(bmdata_path)
  cat("✔ biomod_data4layers carregado do checkpoint.\n")
} else {
  biomod_data4layers <- run_safe(quote(
    BIOMOD_FormatingData(
      resp.var = resp.var,
      expl.var = env_calib,         # <<< calibração só dentro de M
      resp.xy  = coords,
      PA.nb.rep = 5,
      PA.nb.absences = 600,
      PA.strategy = "random",
      # IMPORTANTE: com M pequeno, distâncias grandes quebram o sorteio de PA.
      PA.dist.min = 0,
      filter.raster = TRUE,
      resp.name = "Vampyrum.spectrum"
    )
  ), checkpoint_file = bmdata_path)
}

# ======================================================
# 6) Model options (anti-overfitting) + ajuste RF
# ======================================================
myOptions <- BIOMOD_ModelingOptions(
  # RF um pouco menos "amarrado" que seu setup anterior
  RF = list(n.trees = 800, mtry = 2, nodesize = 10, maxnodes = 50),

  GBM = list(n.trees = 2000, interaction.depth = 2, shrinkage = 0.005,
             bag.fraction = 0.5, n.minobsinnode = 10),

  MAXENT = list(betamultiplier = 3, features = "lq"),

  GLM = list(type = "simple", interaction.level = 0, test = "BIC"),

  GAM = list(algo = "GAM_mgcv", type = "s_smoother", k = 3, interaction.level = 0)
)

# ======================================================
# 7) Modelagem (checkpoint)
# ======================================================
models_path <- file.path(output_dir, paste0("models_buffer_", buffer_km, "km.rds"))

if (file.exists(models_path)) {
  models_4layers <- readRDS(models_path)
  cat("✔ models_4layers carregado do checkpoint.\n")
} else {
  cat("Executando BIOMOD_Modeling (CV block)...\n")

  models_4layers <- BIOMOD_Modeling(
    bm.format = biomod_data4layers,
    modeling.id = paste0("buffer_", buffer_km, "km"),
    models = c("GLM","GAM","GBM","RF","MAXENT"),
    bm.options = myOptions,
    CV.strategy = "block",
    CV.nb.rep = 5,
    var.import = 3,
    metric.eval = c("TSS","ROC")
  )

  saveRDS(models_4layers, models_path)
  cat("✔ Modelagem salva.\n")
}

# ======================================================
# 8) Projeção: MAPA GRANDE (não altera dimensão)
# ======================================================
projections_path <- file.path(output_dir, paste0("projections_buffer_", buffer_km, "km.rds"))

if (file.exists(projections_path)) {
  projections_4layers <- readRDS(projections_path)
  cat("✔ projections_4layers carregado do checkpoint.\n")
} else {
  cat("Executando BIOMOD_Projection no MAPA GRANDE...\n")

  projections_4layers <- BIOMOD_Projection(
    bm.mod = models_4layers,
    proj.name = paste0("current_buffer_", buffer_km, "km"),
    new.env = env_data4layers,    # <<< mapa grande aqui
    models.chosen = "all"
  )

  saveRDS(projections_4layers, projections_path)
  cat("✔ Projeções salvas.\n")
}

# salvar rasters das projeções individuais (se disponível)
proj_stack <- tryCatch({ get_predictions(projections_4layers) }, error = function(e) NULL)
if (!is.null(proj_stack)) {
  proj_names <- names(proj_stack)
  for (i in seq_len(terra::nlyr(proj_stack))) {
    camada <- proj_stack[[i]]
    nome <- proj_names[i]
    terra::writeRaster(camada, file.path(output_dir, paste0("proj_", nome, ".tif")), overwrite = TRUE)
  }
  cat("✔ Projeções individuais salvas.\n")
} else {
  warning("get_predictions(projections_4layers) retornou NULL — pulando export das projeções.")
}

# ======================================================
# 9) Ensemble
# ======================================================
ensemble_path <- file.path(output_dir, paste0("ensemble_buffer_", buffer_km, "km.rds"))

if (file.exists(ensemble_path)) {
  ensemble_4layers <- readRDS(ensemble_path)
  cat("✔ ensemble_4layers carregado do checkpoint.\n")
} else {
  cat("Executando BIOMOD_EnsembleModeling...\n")

  ensemble_4layers <- BIOMOD_EnsembleModeling(
    bm.mod = models_4layers,
    models.chosen = "all",
    em.by = "all",
    em.algo = c("EMmean","EMci"),
    metric.select = c("TSS","ROC"),
    metric.select.thresh = c(0.5, 0.7),
    var.import = 3,
    seed.val = 42
  )

  saveRDS(ensemble_4layers, ensemble_path)
  cat("✔ Ensemble salvo.\n")
}

ensemble_eval <- tryCatch({ get_evaluations(ensemble_4layers) }, error = function(e) NULL)
if (!is.null(ensemble_eval)) {
  write.csv(as.data.frame(ensemble_eval),
            file.path(output_dir, paste0("ensemble_evaluations_buffer_", buffer_km, "km.csv")),
            row.names = FALSE)
  cat("✔ Ensemble evaluations salvos.\n")
}

# ======================================================
# 10) Ensemble Forecasting (MAPA GRANDE)
# ======================================================
ensemble_proj_path <- file.path(output_dir, paste0("ensemble_forecast_buffer_", buffer_km, "km.rds"))

if (file.exists(ensemble_proj_path)) {
  myBiomodEnsembleProj <- readRDS(ensemble_proj_path)
  cat("✔ Ensemble forecasting carregado do checkpoint.\n")
} else {
  cat("Executando BIOMOD_EnsembleForecasting...\n")

  myBiomodEnsembleProj <- BIOMOD_EnsembleForecasting(
    bm.em = ensemble_4layers,
    proj.name = paste0("ensemble_buffer_", buffer_km, "km"),
    models.chosen = "all",
    new.env = env_data4layers,     # <<< mapa grande aqui
    binary.meth = c("TSS","ROC"),
    compress = FALSE
  )

  saveRDS(myBiomodEnsembleProj, ensemble_proj_path)
}

# ======================================================
# 11) Extrair avaliações individuais (TSS/ROC) e salvar
# ======================================================
cat("Extraindo avaliações dos modelos (TSS/ROC)...\n")
model_evaluations_raw <- tryCatch({ get_evaluations(models_4layers) }, error = function(e) NULL)
if (is.null(model_evaluations_raw)) stop("Não foi possível extrair get_evaluations(models_4layers).")

model_evaluations <- as.data.frame(model_evaluations_raw)

tss_data <- model_evaluations %>%
  filter(metric.eval == "TSS") %>%
  transmute(Modelo = as.character(algo), Valor = as.numeric(validation))

roc_data <- model_evaluations %>%
  filter(metric.eval == "ROC") %>%
  transmute(Modelo = as.character(algo), Valor = as.numeric(validation))

write.csv(tss_data, file.path(output_dir, paste0("tss_data_buffer_", buffer_km, "km.csv")), row.names = FALSE)
write.csv(roc_data, file.path(output_dir, paste0("roc_data_buffer_", buffer_km, "km.csv")), row.names = FALSE)

cat("Médias TSS por algoritmo:\n")
print(tss_data %>% group_by(Modelo) %>% summarise(media = mean(Valor, na.rm=TRUE), .groups="drop"))

cat("Médias ROC por algoritmo:\n")
print(roc_data %>% group_by(Modelo) %>% summarise(media = mean(Valor, na.rm=TRUE), .groups="drop"))

# ======================================================
# 12) Plot básico (TSS/ROC)
# ======================================================
ordered_levels <- c("GLM","GAM","GBM","RF","MAXENT")
tss_data$Modelo <- factor(as.character(tss_data$Modelo), levels = ordered_levels)
roc_data$Modelo <- factor(as.character(roc_data$Modelo), levels = ordered_levels)

tss_plot <- ggplot(tss_data, aes(x = Modelo, y = Valor, fill = Modelo)) +
  geom_violin(alpha = 0.35, trim = TRUE, color = NA) +
  geom_boxplot(width = 0.35, alpha = 0.9, outlier.size = 1.2) +
  geom_hline(yintercept = 0.7, linetype = "dashed", color = "red") +
  scale_fill_viridis_d(option = "C", alpha = 0.7) +
  theme_minimal() + ylim(0,1) +
  labs(title = paste0("TSS (CV block) | Buffer ", buffer_km, " km"), y = "TSS", x = "Modelo") +
  theme(legend.position = "none", plot.title = element_text(hjust = 0.5, face = "bold"))

roc_plot <- ggplot(roc_data, aes(x = Modelo, y = Valor, fill = Modelo)) +
  geom_violin(alpha = 0.35, trim = TRUE, color = NA) +
  geom_boxplot(width = 0.35, alpha = 0.9, outlier.size = 1.2) +
  geom_hline(yintercept = 0.8, linetype = "dashed", color = "red") +
  scale_fill_viridis_d(option = "C", alpha = 0.7) +
  theme_minimal() + ylim(0,1) +
  labs(title = paste0("ROC (CV block) | Buffer ", buffer_km, " km"), y = "ROC (AUC)", x = "Modelo") +
  theme(legend.position = "none", plot.title = element_text(hjust = 0.5, face = "bold"))

eval_plot <- tss_plot / roc_plot + plot_annotation(
  title = paste0("Avaliação dos Modelos (Buffer na calibração | Projeção no mapa grande) | ", buffer_km, " km")
)

ggsave(file.path(output_dir, paste0("avaliacao_buffer_", buffer_km, "km.png")),
       eval_plot, width = 14, height = 10, dpi = 300)

cat("Script finalizado. Saída em:", output_dir, "\n")
